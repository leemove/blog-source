<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一起读读Vue(1)]]></title>
    <url>%2F2017%2F12%2F23%2FVue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[起点Vue是一个流行的Js框架,和Google的Angular,FaceBook的React相类似.Vue在2016年得到了爆发式增长.写这篇博客时,npm对他的下载量统计. 作为一个长期使用Vue框架的开发者,Vue的API设计和灵活性在开发中会让你感觉十分顺畅,解决一些常见的问题时变得不那么复杂.如果你有过使用Vue的经验,我相信你也会对他赞不绝口. 好吧,话不多说,开始源码吧! 如果你跟我一样有一点js,dom基础,我相信读起来不会太吃力. 入口首先从github 上下载了2.5.2版本的代码,目录结构如下,我们大致可以看出一些目录的含义. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647├─dist # 打包后的文件目录├─src # 源码目录 也就是我们最关心的文件夹│ ├─compiler # 编译相关?│ │ ├─codegen│ │ ├─directives│ │ └─parser│ ├─core # 核心相关│ │ ├─components│ │ ├─global-api│ │ ├─instance│ │ │ └─render-helpers│ │ ├─observer│ │ ├─util│ │ └─vdom│ │ ├─helpers│ │ └─modules│ ├─platforms # 平台│ │ ├─web # web平台 也就是我们的入口文件夹│ │ │ ├─compiler # 编译│ │ │ │ ├─directives│ │ │ │ └─modules│ │ │ ├─runtime│ │ │ │ ├─components│ │ │ │ ├─directives│ │ │ │ └─modules│ │ │ ├─server│ │ │ │ ├─directives│ │ │ │ └─modules│ │ │ └─util│ │ └─weex # week平台│ │ ├─compiler│ │ │ ├─directives│ │ │ └─modules│ │ ├─runtime│ │ │ ├─components│ │ │ ├─directives│ │ │ └─modules│ │ └─util│ ├─server # 服务端渲染?│ │ ├─bundle-renderer│ │ ├─optimizing-compiler│ │ ├─template-renderer│ │ └─webpack-plugin│ ├─sfc│ └─shared└─types 目前大部分应用都在web平台,那我们就先看看web目录吧.打开index.js. 因为Vue是使用flow这个js类型检测工具所书写的,所以变量方法后面都会有类型声明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* @flow */// #加载各种配置// install platform specific utilsVue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.isReservedAttr = isReservedAttrVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElement// install platform runtime directives &amp; componentsextend(Vue.options.directives, platformDirectives)extend(Vue.options.components, platformComponents)// install platform patch functionVue.prototype.__patch__ = inBrowser ? patch : noop// 定义$mount方法// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125;// # 处理浏览器插件的支持// devtools global hook/* istanbul ignore next */Vue.nextTick(() =&gt; &#123; if (config.devtools) &#123; if (devtools) &#123; devtools.emit('init', Vue) &#125; else if (process.env.NODE_ENV !== 'production' &amp;&amp; isChrome) &#123; console[console.info ? 'info' : 'log']( 'Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools' ) &#125; &#125; if (process.env.NODE_ENV !== 'production' &amp;&amp; config.productionTip !== false &amp;&amp; inBrowser &amp;&amp; typeof console !== 'undefined' ) &#123; console[console.info ? 'info' : 'log']( `You are running Vue in development mode.\n` + `Make sure to turn on production mode when deploying for production.\n` + `See more tips at https://vuejs.org/guide/deployment.html` ) &#125;&#125;, 0)export default Vue 这个文件主要分成三部分: 第一段加载了许多不知名的文件和配置,没有一个熟脸. 声明方法,$mount方法我们还是很熟的. 插件支持 1234567Vue.prototype.$mount = function ( el?: string | Element, // 选择器 hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 原来每次挂载都调用了mountComponent,我们有必要看一下这个nb的函数.他的位置在core/instance/lifecycle.js,看起来应该是生命周期的文件.嗯,下一次我们就更新声明周期吧.]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC-MVVM]]></title>
    <url>%2F2017%2F09%2F04%2FMVC-MVVM%2F</url>
    <content type="text"><![CDATA[从前端角度探讨下MVVM MVC首先声明一点,我不敢说让你花几分钟就可以完全理解这些概念.这篇文章是我个人的理解,并不一定完全正确!!!欢迎指正和讨论. 最近前端工程化越来越普遍完善了,面试的时候也总会被问到MVC,MVVM这类的架构名词,第一次听肯定让人很费劲,但是千万不要想得太难,其实非常非常的简单好理解,这篇文章主要会结合前端的业务场景来解释解释这些概念. 什么是M , V , CModelM: Model 模型 也就是一个抽象对象的模型,作为一个小前端,你是不是也写过express呢?在express中一个最普通的模型可以就是这样的.很简单. 1234const Person = &#123; name: String, age: Number&#125; 这就是一个人类的模型,有两个属性,一个是名字必须是字符串,另外一个就是年龄必须是数字.如果实例出一个对象的话可能就是小明,24岁这种感觉.Model层只关心数据最基础的增删改查. ViewV: View 视图 也就是我们所看到的.我们存在model的数据当然要展示出来了,展示在网页,展示在html里面.view就可以当成一个静态页面.View只关心数据的显示. ControllerC: Controller 控制器 我们已经有了模型Model要显示在View上,如果像上例一样的简单数据,可以直接拿去显示,但是数据有时候不是单纯的为了显示,会有增删改的需求.这时候我们的Controller控制器就出现了.可以控制数据的家伙就是他. MVC 组合之后 图片来自阮一峰大大的博客. 所以一次完整的交互结合实际大概是这样的. View层网页显示了来自Model的数据,用户说我要改这条数据,点击了一下网页View,Controll收到来自View的反馈,赶紧去修改数据,也就是找Model.Model变了之后,用户再次获取数据的时候,数据已经更新过了!这就是传统的MVC. MVVM一眼直接看上去,你大概可以看到,少了个C多了个V和M.难道有两个ViewModel其实不是这样的.现在Vue和Angular这两款主流框架都包含了一个很nb的功能,叫做双向绑定.应运而生的类似概念就是ViewModel也就是VM.VM相比较C有一点很方便就是&quot;双向流&quot;. 双向的好处就是ViewModel不在只能操作Model了,可以直接去操作View更改视图.同时可以在获取数据之后进行加工,处理再显示到View上.减少了许多不必要的操作. 我的理解这些概念其实并不复杂,但是还没有确定准确的标准,所以会导致很混乱.阮一峰老师的和MSDN之间就有很大的差别.所以这个东西主要还是理解怎么去用,怎么去思考,并没有一个太标准的答案,就像angular称自己为MVW,W:Whatever.你懂得怎么把将项目按照逻辑区分层次,知道每个层级该做什么,不能做什么就足够了.开心就好.]]></content>
      <tags>
        <tag>Angular Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新浪财经面试]]></title>
    <url>%2F2017%2F05%2F04%2F%E6%96%B0%E6%B5%AA%E8%B4%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[新浪财经面试上次保险公司的面试让我感觉就很高大上了,结果今天新浪财经来了一发…感觉我快要突破次元了.问了很多底层的原理,没有阅读过源码感觉很难准备充分,感觉到自己还是有挺多的不足,不过真的是收获满满. ​ 面试的问题因为面试聊到了许多不懂得点,可能记录没有那么详细.还有一些不是太复杂的点,这里可能就不写了. H5有哪些新标签,CSS3有什么特性可以在IE8当中使用? 听到这个问题就知道,会有一大批非常较真的问题出现,以往的开发中,可能被忽略的许多点,这里都会被问到.万万没想到随口说了一些选择器和一个querySeleeter 又追着querySeleter问了一圈. 正解是ie8确实支持一部分h5的标签. Vue的脚手架完美吗? 我真的是嘴有问题,被面试官套路到Vue的脚手架,随口说了一个完美,结果面试官说脚手架真的很完美吗?尤雨溪刚刚说了要重写脚手架.听到这句话我的内心是崩溃的,去的路上随便翻,翻到了Vue2.3刚刚发布,没想到这么快就问到了相关的. 也是说了一些其他的都是些暗藏杀机的问题,比如你说的单页应用路由是前端写还是服务器写,跨域是浏览器行为还是服务器行为.最后卡在了一个点上,我一直以为vue的脚手架使用express结合webpack来进行一个网页的热加载,他说vue脚手架只是用了express的核心功能,并没有使用express, 但是vue-cli的devDependencies中确确实实是有express的.可能我没有完全理解面试官的意思,或者我表达出来的有问题. 跨域是什么,同源是什么?jsonp的原理跨域和同源都是比对着自己的理解说了一通,表达的非常不好,也不全面.jsonp的原理说了很长时间,每次说一点他都会问一点,最后卡在了自己封装jsonp的时候要怎么判断数据是否返回,等等一系列的状态. 同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。不同元则跨域. 当时我的回答是jquery中是通过时间来判断,当超过一定时间,这个回调函数没有被调用,就会报错,他反复问我当没有返回数据的时候,这个回调函数不会被调用吗?我说不会.他指出了我的不正确,让我回来看看.正确答案是貌似script标签是有一组事件的onload和error,但是ie67没有这两个事件. zepto的tap事件说一下tap事件的原理,说出了底层是用touchstart,touchend来完成的,但是我说的是定时器来计时,其实应该是用的事件戳,但是我脑抽啊,面试官各种反复提醒我,我还是想不起来时间戳. node支持不支持es6的模块化?为什么我干脆没想过这个问题,回答的应该是支持,其实是一直不支持的.node作为一个偏向服务端的生态,主要是用动态加载,而es6偏向客户端更多是静态加载,所以node没有推行. float是怎样被浏览器解析的?以及float的影响简单的提到了渲染引擎,估计说的也是错的,根本没达到人家想问的点.浮动也只是说的很片面..float全解第一个问题干脆就没有仔细的理解过 mogoose相比直接操作数据库,仅仅是因为更加便利吗?在我的印象里mogoose真的是仅仅提供了便利,就像jquery的dom操作,可是现实好像并不是这样的,对数据库我也不是很了解,面试官就没有继续问了. g-zip是干嘛的?大致回答了一下他的功能,是起到一个压缩的作用,面试官追问是服务端发送的,还是客户端先发送的.没经过大脑直接甩出了一句服务端,后来仔细一想浏览器不支持g-zip服务器也不能强行发送啊.真的是脑抽. mvc和mvvm的区别这里也主要是读了一篇阮一峰的博客,但是感觉还是说的不是很透彻mvvm-mvc详解这里还问到了angular到底是mvvm还是mvc,我回答的是mvvm但是文档宣称是mvw.感觉并没有理解到他们需要的高度.需要仔细的研究. ​requreJs的原理回答的是动态创建script标签,然后通过异步请求先执行依赖中的代码,最后调用声明的函数. 说些vue2的新特性v-dom吧我只是能说出个大概的过程,结果卡在了内存,和diff算法上.解析vue diff算法 ​浅拷贝和深拷贝问到这里感觉是已经知道我的层次可能没有他们要求的那么高,问了一些简单点的问题,这里也是回答了jquery中的extends方法 ​变量的提升和预解析面到了这里已经到了JS基础了…做了一道笔试题,应该是没问题的吧,大概.这种题百度以下就有很多.我想说的话这一次面试的新浪属于是一家特别大的互联网公司,也是第一次面试这种巨头互联网公司,感触还是很多的.不要说使用,我想听原理不要你感觉,不知道就是不知道这个好像不太对(冷笑),你在回去看看吧.这次面试上面的三句话还是让我印象深刻的,规模不通的公司,面试的内容天差地别.相比于之前的小公司面试,十分侧重原理,不会问你任何具体的api,只是问你底层的原理,这些原理没有阅读过源码,或者积累过大量的设计思想编程思路等等,是达不到这个高度的.我还差了很大一块. 面试过程中千万不要给自己挖坑,不会的千万别蒙着说,或者扯到一些你不是很了解的技术,给我的感觉就是他会问你提到的所有技术,所以尽量不要提你不懂得的点. 经历过这次面试,也是给自己明确了一个学习的方向或者方法吧.就是全部的框架也好,库也好必须最低最低也要深入了解到原生js这层,不能仅仅有一个模糊的印象.还有许多细节的问题比如标准流应该叫做文档流这些也都应该注意起来. 虽然这次面试一点都不成功,但确实真真切切的和技术大牛有了一次沟通的机会.多读源码,多深究,不要不求甚解.自己对自己的要求,很大程度上决定了自己是一个什么样的档次.]]></content>
      <tags>
        <tag>rubbish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-25面试]]></title>
    <url>%2F2017%2F04%2F26%2Finterview3%2F</url>
    <content type="text"><![CDATA[4-25面试第一次面试一个大公司,知名的一个保险公司,面试了四轮. 第一轮第一轮的问题比较多,面试我的应该是一个java程序员,懂一些前端,jquery之类的常用类库. 解释下jquery和Vue的区别 我回答的主要区别在于一个是dom操作,另外一个是mvc的开发模式,一般情况下,只要修改数据,dom就会自动更新视图. 应该回答下具体的情境下,开发模式的优点,比如购物车等等.. 前端有什么安全措施 我回答了XXS防止注入攻击,详细的解释了一下应该还是可以的.面试官为我指正了一些其他的安全缺陷.比如劫持攻击,和什么是https. 跨域是什么,jsonp跨域的原理 这个问题已经在很多地方我都写过答案了,就不在重复了. 怎么优化网络的加载速度说了一下雅虎13条中的几个. 前端的级别,技术难度是怎么区分的​这个题应该是仁者见仁,智者见智了吧.而且第二轮 又问了一遍怎么在前端角度保护数据的安全.2.. 第二轮面试我的竟然是校友,但是听口音应该不是东北人,特意问了一些学校的事情.基本没怎么聊就去面试技术经理了第三轮. 技术经理是一个30多些的电影中的白领女性的的感觉,说话很温柔.焦总. 你在开发一个项目中,最重视的部分是什么?我回答的是项目的结构化,模块化,但是她给我的反馈仿佛是这也太low了.应该动动脑筋,直接回答上面两位面试官问的安全问题. 你最近研究的方向是什么?回答了移动端,RN这个框架,还说了一下nodeJS,全栈.她说你还离这个很远.. 面试官还是非常不错的,给我提了许多个建议 人事面试的时候要穿正装. 和人说话的时候最好看他的眼睛. 还交了我不少其他的,可能大家都知道,就不在这里啰嗦了.第四轮人事面试,其实到这里也就是走个形式了,面试通过不通过主要还是看总公司允许不允许招人.这里就不详细的说了.面试相关的故事后来加了项目leader的微信,可能因为是校友吧,他说了他们公司的情况,招聘被冻结了,希望我能去面试他推荐的一个外包公司,然后也是帮他们公司干活.后来去面试了外包公司.可能是因为人云亦云吧,总感觉外包公司不是很好,薪水要了11个,感觉面试官还是感觉高,他根本也没问到我的技术,而且特意多次强调我是16年毕业的,可能薪水判断的主要途径还真的就是这个毕业时间. 这个行业真的开始拿毕业证来计算一个人的能力了,感觉还是不是很理解,不过也就这样吧.作为一个小屌丝程序员,我哪有那么多选择呢,你们开心就好.]]></content>
      <tags>
        <tag>rubbish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-markdown]]></title>
    <url>%2F2017%2F04%2F24%2Fvue-markdown%2F</url>
    <content type="text"><![CDATA[挖个坑.]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-19面试心得总结]]></title>
    <url>%2F2017%2F04%2F19%2Finterview2%2F</url>
    <content type="text"><![CDATA[4-19面试面试的是一家规模稍大的一家互联网投资公司,大概吧.不太理解这些投资类,金融类的人都靠什么来赚钱. 有些很可怕的事情发生了… 面试过程根据昨天的面试情况,今天也是抱着跟着去玩的心态去尝试下,结果聊得比上次好一些,薪资要的可能有点高了.单位在西二旗上地附近. 第一轮面试官应该是个leader,一直在诈我,故意说错一些常识性的问题,而且说得非常逼真.我的内心也是很崩溃的,感觉差点就顺着他走了. 第二轮面试官是一个后台PHP程序员,对前端这一块应该是写过的,不过不太了解前端一些新的技术和框架,大概聊了下前后端渲染的区别,最主要问的就是各种项目的周期,对接接口的时间,速度.我感觉我当时回答的时间太长了,站在他一个后端的角度上,我应该告诉他,用PostMan来调接口,收到数据了,就格你没关系了,剩下的我来,很快的.我回答的预估事件都太保守了,应该说的短一点.这个时候指出了我的项目撞车了..我的内心是崩溃的. 第三轮是个人事的小姐姐,知道自己没戏了,让我简单介绍了下自己的薪资期待,和上一家的待遇.简单说了说,说等领导回来通知我. 我想说的话北京这头面试问的问题真的是千奇百怪,公司的人员构成不一样,面试的人不一样,侧重点还是有很大的区别的,人的性格不一样他欣赏的人也就不一样.所以对一个人的个人要求还是很高的.会这些,会那些,都需要没问题才可以. 短时间内还没有接到面试了,希望可以赶紧Get一个不错的Offer吧.]]></content>
      <tags>
        <tag>rubbish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-18面试题总结]]></title>
    <url>%2F2017%2F04%2F19%2FinterviewQuestion1%2F</url>
    <content type="text"><![CDATA[面试总结4-18,4-17两天的面试题总结.包含了一些面试题,可能比较基础比较细节. angular路由表示hashangular中$location服务可以获取到当前地址栏的参数是基于window.location.通过这个服务我们可以获取并且监听当前的url,改变url. 当改变了地址栏,点击了后退按钮,或者点击了一个连接的时候就会触发.可以设置h5模式和普通模式. ng-if ng-show的区别ng-if是决定是否去渲染这个元素,而ng-show是是否用css来让这个元素是否显示. ng-if不会保留DOM的一些状态,并且会删除作用域.而ng-show会保留元素的一些状态. 解决ng-repeat重复内容报错ng-repeat 可以使用item in items track by $index很坑爹,竟然跪在了这一行代码 可以把数据转换成引用类型,这样即使内容是一致的,因为地址是不相同的,所以不会报错.自定义过滤器 比较简单,直接上代码了.1234567891011app.filter('ifLogin', function () &#123; return function (target) &#123; if (target == "0") &#123; return "在职"; &#125; else &#123; return "离职"; &#125; &#125;&#125;); block，inline和inlinke-block细节对比 display:block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block 简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。flex 布局 主轴justify-content align-items属性 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。一些我想说的话来总结这些问题,其实是很痛苦的一件事啊,回忆自己被面试官吊打的经历…不过我估计这样痛苦的事情可能还要经历很多次… 面试可能并没有问那些高大上的JS原理问题,更多的是基于实战,问一些奇淫巧技,框架的使用等等.之前我一直认为框架这些东西,知道怎么去使用,就算使用错了,修改修改,查查文档能够写出合格优秀的产品才是唯一的目的.主要的学习方式应该是看看源码,熟悉底层的原理.现在看来要想过面试这关,主要还是考使用方面的问题比较多.]]></content>
      <tags>
        <tag>rubbish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-18面试旅程]]></title>
    <url>%2F2017%2F04%2F18%2Finterview1%2F</url>
    <content type="text"><![CDATA[面试总结下这几天面试的经历吧,槽点满满.会有问题,和心路. 面试了两家公司,感觉机会都不大,薪资也是随便要的. 第一天面试了一个创业公司,老总直接面试,老总不太懂技术,这就很尴尬了,我看的出来他有一个伟大的梦想.但是我和他沟通不到一起去,这里就不多说了.公司的环境给我很大的落差感,感觉不太适合我. 第二天以为是一个网络公司,以为这下可好了,毕竟通信出身,网络问题没毛病啊,就怕不问这些通信协议. 可是我万万没想到啊,其实是一家金融公司,想开发一个PC端的金融产品商城,还有微信端JS,SDK的开发,移动端Rn,这个就很悲剧了.一路做两小时地铁干到东直门.面试我的竟然是一个94年的小妹,嗯,很漂亮,我毕竟中年人,世界是他们的.哭..好处就是感觉可以稍微放松点,不是特别紧张. 问题第一天没有问到什么问题,面试官是老总就问了下H5,和一些简单的知识点这里就不重复了. 第二天美女小妹面试的问题有 angular,router表示hash值的参数是哪一个 ​ 完全不记得,一点印象都没有了,第一个问题就悲剧了. angular ng-if,ng-show的区别记忆中还有点印象,大概的和他说了一遍 angular的双向绑定 ​ 这个问题比较了解,大概给妹子说了一遍,但是好像说的不太透彻 angular的控制器之间的通信 ​ 这个问题就很坑爹了,好像有漏答,不过说出来了一两种常用的方法 ng-repeat的$index索引 ​ 这个问题很简单不聊了 ng-repeat相同的值报错问题怎么解决 ​ 回答是把数据修改成引用类型的数据,因为引用类型在JS底层是不会判断相等的,不知道对不对 -+——————————————————————————————自定义指令 里面怎么接收的数据 angular过滤器 ​ 简单了说了下,然后让我写一个把字体变红的过滤器,完全懵逼,会真的有人记住这种细节问题吗,于是进行了一个判断,然后返回了一个p标签,加上了个calss然后三元表达式还没写冒号和后面半句,紧张了 封装过jq插件吗,为什么使用自执行函数 自执行主要是为了防止变量对全局作用域的污染,有什么更好的方法吗,我回答的是通过第三方的模块化工具,比如requireJs,webpack等等. jquery angular Vue 之间的区别 感觉这是一个主观问题,我站在使用者角度说了一些,感觉她也不是很满意. 然后是CSS问题,问了inline和inline-block的区别 ​ 这个问题我以为很基础根本不会有人问的,结果她真的问了,我真的没准备,平时用起来都是凭直觉,不好使换换,这方面真的没注意 然后清除浮动的几种方式 回答了伪元素,ovh等等常用的方法,果然不出所料问我bfc了.bfc这个东西单拿出来感觉比整个js都难,非常简略的讲了一讲,感觉回答的不是很好. flex布局.如何让盒子居中 CCS3是我最头疼的了,好多单词根本没记住,只把思路说了一下. － angular的一些具体问题 比如页面上的手风琴特效之类的细节问题 ## 总结总以为会问一些相对高大上，难度复杂点的问题，最少也是从异步交互,一直问到nodeJs啊,结果问的都是些基础，很伤心，越问越简单，越问越没底，本来会的一些东西，一着急就说不出来了，还有很多问题有更好的回答，当是一时语塞，都没讲出来自己的想法． 悲剧的一天就这样结束了,估计面试会越来越少了,也不知道后续能不能达到一天一面. 一些我想说的话其实内心是有点不开心的,一些朋友们,技术和我差不多的,都找到了非常棒的工作,而我始终认为我自己并不比他们差,论技术,我真的不怂.可是现实并不是完全靠技术的.是很多复杂的因素东西结合在一起,叫做运.好运气,只是表象,很多深层的条件,准备才能得到这种好运气. 追求卓越吧,不要去追逐成功. 我会把这些面试题总结出来,有时间的时候上传到博客.]]></content>
      <tags>
        <tag>rubbish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery源码阅读之整体架构]]></title>
    <url>%2F2016%2F06%2F03%2Fjquery%20%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[JQuery 骨架JQuery作为前端的基本功，每个前端都必然使用过，作为一个前端的初学者很好奇内部的源码。今天开始将逐渐阅读一些JQuery源码，来解析他的设计思路，和一些小技巧，加深面向对象技能。 JQuery到底是方法还是对象这个问题非常困扰我，JQuery既可以点出方法，明明是一个对象，可是又可以加个括号来当选择器，明明是一个方法。那么JQuery到底是什么。这里不得不说一个function都能做些什么？ tips:function都有什么用法？ 当做一个构造函数 用new调用 当做一个普通的方法 直接用()调用 当做一个对象 是一个不太普通的对象 继承Object 我好像懂了什么，JQuery应该是一个函数，只不过利用了函数也可以当做对象的特征而已，把方法都存在了他的原型中。那么可能是这样的。 首先要有一个JQuery方法，参数可以传入选择器，这里我们就只能根据TagName选择了，然后返回一个类数组对象。我们可以这么写。12345678910111213141516function JQuery(selete) &#123; return new JQuery.prototype.init(selete);&#125;JQuery.prototype=&#123; //构造方法 生成对象用 init: function (selete)&#123; var doms=document.getElementsByTagName(selete); //造一个类数组的结构 for(var i=0;i&lt;doms.length;i++)&#123; this[i]=doms[i]; &#125; this.length=doms.length; &#125;, //我是JQuery内置的各种对象方法。 method:function()&#123;&#125;&#125;; 怎么实现JQuery的全局方法和对象方法。按照上面的例子分析，实现下来也非常的简单。123// 把init的实例都继承上JQuery原型上的方法，这样就可以了像Jquery一样，直接用Jquery对象来调用了。 JQuery.prototype.init.prototype=JQuery.prototype; JQuery.fn=JQuery.prototype; 我们只要把init这个构造函数的原型指向JQuery的原型就可以了，这样就可以继承到JQuery中的方法。 全局方法呢，平时我们经常用$.method来调用的方法也不难实现了。可以直接把JQuery这个函数本身当做一个对象，就可以添加方法了。1234$=JQuery;$.ajax=function()&#123; console.log("我可能是一个假的方法")&#125; 总结以上代码算不上完美，但是没毛病。总结起来就是这样的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function JQuery(sel)&#123; return new JQuery.prototype.choose(sel); &#125; JQuery.each= function (objs,callback)&#123; for(var i=0;i&lt;objs.length;i++)&#123; callback.call(objs[i],i,objs[i]); &#125; &#125; JQuery.fn=JQuery.prototype = &#123; choose: function (selete) &#123; var divs=document.getElementsByTagName(selete); for(var i=0;i&lt;divs.length;i++)&#123; this[i]=divs[i]; &#125; this.length=divs.length; &#125;, each: function (callback)&#123; $.each(this,callback); &#125; &#125; JQuery.prototype.choose.prototype=JQuery.prototype; var $=JQuery; onload=function ()&#123; var adiv=$("div"); console.log(adiv); ad.each(function (index,dom)&#123; this.innerHTML=index; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/html&gt; 这里实现了一个JQuery的each方法，并且还原了JQuery大致的骨架。你对JQuery的思路有一个大致的了解了么。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax入门]]></title>
    <url>%2F2016%2F05%2F01%2Fajax%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[ajax入门AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。还会介绍Jquery封装的ajax和跨域问题。 何为异步在网页加载的过程中，浏览器需要不断的从服务器通过http协议获取资源，来完成加载。主要方式有同步方式，和异步方式。在同步方式中，浏览器必须和服务器保持同步，只有相互间收到反馈时才会进行下一步，而异步则是不需要等待，直接进行下一步。 在传统的网页中，当提交表单的时候需要刷新整个页面，而新页面大部分页面和原页面相同。而通过异步技术可以只改变网页部分的内容，不需要刷新整个网页，大大减少了服务器的负担，但也伴随着浏览器无法后退的缺点。 如何通过JS发送异步请求AJAX不需要浏览器插件的支持，对服务器来说也只是一个普通的请求，只需要浏览器提供XMLHttpRequest对象。在老版本IE中存在兼容性问题，这里就不讨论了。 新建一个AJAX对象var xhr=new XMLHttpRequest();虽然对象名称包含XML，但实际上是可以传输其他数据的，比如JSON。 打开连接xhr.open(&quot;GET&quot;,&quot;1.php?username=leemove&amp;password=what&quot;); open函数包含了两个参数，第一个参数是HTTP协议的传输类型，主要使用的有POST，GET。第二个参数是请求的url如果是GET方法需要在地址后面加上?后面写传送的数据用&amp;隔开。 tips: GET POST的区别 GET发送的数据要写在URL中，部分情况下可能会显示到浏览器的地址框中，GET没有请求体，不太安全。POST的数据会放在请求体中，相对安全。 因为GET的数据在地址栏中，所有会有大小的限制，当传送大量的数据时，要使用POST。 POST在AJAX中必须设置q请求头Content-Type:application/**** GET因为没有请求体，性能会高一些。 发送数据xhr.send(null);因为GET没有请求体，所以发送的数据就是null，如果是POST可以发送内容。 接收数据12345678//注册事件当状态改变时触发 xhr.onreadystatechange=function () &#123; //判断当前的传输是否完成 if(this.readyState==4&amp;&amp;this.status==200)&#123; //接收数据 var data=this.responseText; &#125; &#125;; onreadystatechange事件将会在状态改变的时候被触发。readyState参数分别对应了五个状态 0：尚未初始化。未调用open()之前 1：启动。调用open()之后，但是未调用send(); 2：发送。调用send()但是尚未得到响应。 3：正在接收数据。刚接收到响应数据开始到接收完成之前。 4： 完成。数据接收完成 status指HTTP中的状态码，常见的状态码有 200：OK 304： 数据未修改，可以调用缓存，根据最后修改事件判断。 404：没有请求的资源 500：服务器内部错误 405：请求的方式不支持 302：请求的方式不支持 403：没有访问的权限 responseText也可以换成responseXML只是接受的数据格式不同。 jquery封装的AJAX方法。ajax也为我们封装了ajax方法，可以通过全局变量$来直接调用。方法需要一个对象作为参数，对象可以有以下的属性： type 传输的类型，可以是GET— data 要传输的数据 可以是字符串，但最好使用JSON dataType 数据的类型，平时可以不设置，但跨域则必须使用jsonp，下一节将会讲解跨域 success 成功时会调用的回调函数，并且会把接收到的数据作为参数传入这个函数 error 错误时调用的回调函数 beforeSend 在发送数据之前调用的函数。 还有很多其他的不太常用的 可以通过Jquery的手册来查看调用急速数据的天气接口案例只是简单的一个小例子，并不需要完全理解其他内容。123456789101112131415161718 $.ajax(&#123; type: 'get', url: "http://v.juhe.cn/weather/index", success: function (daa) &#123; console.log(daa); var html = template("templateId",daa); console.log(html); $('tbody').append(html); &#125;, data: &#123;// 城市名 cityname: str, //*****注意这里要输入你自己的key key: "我是马赛克，输入你自己的KEY" &#125;, dataType: "jsonp" &#125;); 跨域什么是跨域请求理解跨域必须先理解同源，同源策略是浏览器的一个安全策略，浏览器只会支持同源的请求，所谓的同源也就是指必须有相同的域名，端口,以及协议。 如果 请求不是同源的，那么将会进行跨域，而浏览器为了安全考虑会阻止这个请求，但实际生产中，我们有时候必须进行跨域。12345678例如http://www.example.com/http://api.example.com/detail.html 不同源 域名不同 https//www.example.com/detail.html 不同源 协议不同 http://www.example.com:8080/detail.html 不同源 端口不同 http://api.example.com:8080/detail.html 不同源 域名、端口不同 https://api.example.com/detail.html 不同源 协议、域名不同 https://www.example.com:8080/detail.html 不同源 端口、协议不同 http://www.example.com/detail/index.html 同源 只是目录不同 如何阻止浏览器的拦截跨域行为？？常见的方法有两种，一种是jsonp，一种是CORS jsonp就是利用SRC属性可以跨域的特点。新建一个script标签，并将src设置成请求的url，所以只能用GET请求。然后将script标签加入到页面中，当解析到这个标签的时候就会执行内部的代码。所以可以传入一个回调函数callback，对应自己已经编写的一个函数名，然后将数据当做参数传入。返回的数据格式会是’callback(‘+json+’)’;123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="button"&gt;请求数据&lt;/button&gt;&lt;/body&gt;&lt;script&gt; window.onload=function()&#123; var button=document.getElementById("ibutton"); function callback(data)&#123; //处理data &#125; button.onclick=function()&#123; var script=document.createElement("script"); script="http://www.sasd.com/json/?callbak=callback"; document.body.insertBefore(script,document.body.firstChild);//加载脚本 &#125; &#125;&lt;/script&gt;&lt;/html&gt; 另外一种方法是CORS是利用协议。当浏览器发送请求时，会在请求中标注自己的域名，origin:客户端所在的域服务器如果在x响应头中添加Access-Control-Allow-Origin:请求的客户端地址然后再发给客户端，客户端的浏览器就会允许跨域。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5的语义标签]]></title>
    <url>%2F2016%2F04%2F23%2Ftransform%202d%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[transform 2D变换 利用transform可以进行一些2D的动画效果,不需要依靠JS就可以实现。 translate 位移transform:translate(50px,50px)向右向下移动50px，第一位是x轴正方向是右，第二位是y轴，下是正方向。 rotate 旋转transform:rotate(3600deg) 顺时针旋转3600度，也就是转10圈。 scale 缩放transform:scale(.5,.5) 宽高分别缩放到0.5倍，缩小一半。 如果放大，超出屏幕范围，那么会拉长滚动条skewX 扭曲transform: skewX(-45deg);设置x轴扭曲45度（真的会有人用吗） 也可以设置两个值，分别设定x和y当x和y相当时，元素会消失，不推荐。transform-origin 变换中心点所有的变换以这个点为基准.transform-origin:10px 10px;类似精灵图坐标设定中心点，也可以使用center关键字等等四个小盒子变换12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul&#123; width: 450px; height: 450px; margin: 0 auto; /*border: 1px solid black;*/ &#125; li&#123; margin: 10px; float: left; width: 150px; /*margin-right: 50px;*/ height: 150px; background-color: hotpink; list-style: none; transition: all 1s; transform-origin: 20px 20px; &#125; li:first-child:hover&#123; transform: translate(50px,50px); &#125; li:nth-child(2):hover&#123; transform: rotate(720deg); &#125; li:nth-child(3):hover&#123; transform: scale(2,2); &#125; li:last-child:hover&#123; transform: skew(45deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下:]]></content>
  </entry>
  <entry>
    <title><![CDATA[旋转木马C3动画]]></title>
    <url>%2F2016%2F04%2F10%2F%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[C3小动画介绍简单的C3动画，以及通过C3的动画，常见的旋转木马的效果实现。 C3动画有以下几个属性： 设计动画@keyframes属性关键帧属性，可以设定动画的from开始和to结束，也可以类似渐变设置过程. 123456789@keyframes anima &#123; from&#123;&#125; /* 如果已经是默认状态那么开始状态不用再设计*/ to&#123; /* 设置目标状态 */ &#125; &#125; 也可以用百分比来设计动画过程12345678@keyframes testanimations &#123; from &#123; transform: translate(0, 0); &#125; 20% &#123; transform: translate(20px, 20px); &#125; 40% &#123; transform: translate(40px, 0); &#125; 60% &#123; transform: translate(60px, 20); &#125; 80% &#123; transform: translate(80px, 0); &#125; to &#123; transform: translate(100px, 20px); &#125;&#125; 引入动画的方法一般使用类样式引入，在类样式中设计以下几个属性: animation-name: 动画名称也就是@keyframes 后面的动画名称 animation-duration: 过渡时间，也就是动画的持续时间 animation-timing-function:动画线性 类似过渡方法 animation-iteration-count: 动画的次数 可以设置成正无穷infinite animation-play-state: 动画状态 可以是running进行 paused暂停12345678910111213141516171819202122232425.donghua&#123; /* 使用 哪个动画 */ animation-name: anima; /* 设置动画的 持续时间 */ animation-duration: 2s; /* 动画的线型 */ animation-timing-function: linear; /* 设置动画的次数 可以设置 具体的 次数 也可以设置 无穷次 */ animation-iteration-count: infinite; /* 动画的播放状态 不设置默认是 running 播放 设置为 paused 暂停 */ animation-play-state:running; &#125; .donghua:hover&#123; animation-play-state:paused; &#125; 旋转木马案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; body&#123; perspective: 1000px; &#125; .box&#123; position: relative; /*开启3D渲染*/ transform-style: preserve-3d; margin: 100px auto; background: url("https://www.tuchuang001.com/images/2017/02/01/dog2.jpg") no-repeat; width: 220px; height: 240px; &#125; .box div&#123; position: absolute; width: 300px; height: 300px; background: url("https://www.tuchuang001.com/images/2017/02/01/qt-dog.jpg") no-repeat; &#125; .box div:nth-child(1)&#123; transform: rotateY(60deg) translateZ(300px); &#125; .box div:nth-child(2)&#123; transform: rotateY(120deg) translateZ(300px); &#125; .box div:nth-child(3)&#123; transform: rotateY(180deg) translateZ(300px); &#125; .box div:nth-child(4)&#123; transform: rotateY(240deg) translateZ(300px); &#125; .box div:nth-child(5)&#123; transform: rotateY(300deg) translateZ(300px); &#125; .box div:nth-child(6)&#123; transform: rotateY(360deg) translateZ(300px); &#125; /*.box:hover&#123;*/ /*transition: all 3s;*/ /*transform: rotateY(360deg);*/ /*&#125;*/ @keyframes anima &#123; from&#123;&#125; to&#123; transform: rotateY(360deg); &#125; &#125; .donghua&#123; /* 使用 哪个动画 */ animation-name: anima; /* 设置动画的 持续时间 */ animation-duration: 2s; /* 动画的线型 */ animation-timing-function: linear; /* 设置动画的次数 可以设置 具体的 次数 也可以设置 无穷次 */ animation-iteration-count: infinite; /* 动画的播放状态 不设置默认是 running 播放 设置为 paused 暂停 */ animation-play-state:running; &#125; .donghua:hover&#123; animation-play-state:paused; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box donghua"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下:]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小盒子触摸特效]]></title>
    <url>%2F2016%2F04%2F09%2F%E4%B8%A4%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9B%92%E5%AD%90%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[小盒子触摸特效在许多网页中都有的小盒子特效，鼠标进入小盒子后，小盒子内的图片和文字产生一种类似滑动的特效 2D小特效实现的效果如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; div.wai&#123; margin:50px auto; width: 180px; height: 180px; overflow: hidden; &#125; div.nei&#123; height: 100%; background-color: white; opacity: 0.6; position: absolute; width: 180px; transform: translateY(-100%); z-index: 3; text-align: center; transition: all 1s; height: 180px; &#125; .wai:hover img&#123; transition: all 1s; transform: scale(1.2,1.2); &#125; .wai:hover .nei&#123; transform: translateY(0); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wai"&gt; &lt;div class="nei"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ad, architecto unt, tempora? Accusantium eligendi id ipsa laborum quidem? &lt;/div&gt; &lt;img src="https://www.tuchuang001.com/images/2017/01/25/touxiang.jpg" alt=""&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 盒子3d小特效效果如下:代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; .wai&#123; /*background-color: gray;*/ overflow: hidden; perspective: 800px; width: 180px; height: 180px; margin:50px auto; border: 1px solid black; &#125; .pic&#123; position: absolute; width: 180px; height: 180px; background: url("https://www.tuchuang001.com/images/2017/01/25/touxiang.jpg"); transition: all 1s; transform-origin: bottom center; &#125; .news&#123; width: 180px; position: absolute; background-color: white; opacity: 0.8; transform: translateY(-100%); transition: all 1s; /*width: 100%;*/ &#125; .wai:hover .news&#123; transform: translateY(0); &#125; .wai:hover .pic&#123; transform: rotateX(70deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wai"&gt; &lt;div class="news"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. A cum, numquam quam saepe ut velit! &lt;/div&gt; &lt;div class="pic"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 小骰子特效12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; /*position: absolute;*/ /*设置文字到DIV中央*/ text-align: center; line-height: 200px; font-size: 100px; &#125; .box&#123; position: relative; margin:100px auto; /*开启3D渲染功能*/ transform-style: preserve-3d; &#125; .box div&#123; position: absolute; opacity:0.7; &#125; .box div:nth-child(1)&#123; background-color: hotpink; /*保证骰子的滚动围绕着中间 向前走宽度的一半*/ transform: translateZ(100px); &#125; .box div:nth-child(2)&#123; background-color: coral; transform: translateZ(-100px); &#125; .box div:nth-child(3)&#123; background-color: aqua; /*先旋转再移动 旋转过程中z轴也进行了旋转*/ transform: rotateY(90deg) translateZ(100px); &#125; .box div:nth-child(4)&#123; background-color: brown; transform: rotateY(-90deg) translateZ(100px); &#125; .box div:nth-child(5)&#123; background-color: darkblue; transform: rotateX(90deg) translateZ(100px); &#125; .box div:nth-child(6)&#123; background-color: dimgray; transform: rotateX(-90deg) translateZ(100px); &#125; .box:hover&#123; transition: all 2s linear; transform: rotateY(360deg) rotateZ(360deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下: 注意点： transform-style: preserve-3d 这个属性是开启3d渲染，浏览器默认是不开启的，也就是无法进行任何的3D操作。渲染3d非常占用电脑的资源。 骰子拼接侧面和顶面底面时候先进行旋转，Z轴也就跟着转变方向。]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[perspective属性]]></title>
    <url>%2F2016%2F04%2F08%2Fperspective%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[perspective的介绍perspective属性 这个属性的值会改变一部分变换的效果，单独使用没有明显的效果。 这个属性可以理解为 设置属性的元素距离z=0也就是距离屏幕的距离，单位可以是px。正方向是屏幕的内侧，负方向是屏幕的外侧人的方向。 对要进行动画元素的父元素使用，如果效果不正常那么在对其父元素的父元素使用。当具有这个属性的值，发生动画效果的时候，有时会产生近大远小的效果。 开门大吉案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; div&#123; width: 300px; height: 400px; margin: 50px auto; border: 1px solid black; perspective: 1000px; /*到屏幕的距离 正数是屏幕内*/ &#125; div:before&#123; content:""; width: 50%; height: 100%; float: left; background: url("https://www.tuchuang001.com/images/2017/01/30/door.jpg"); transform-origin: left center; transition: all 1s; &#125; div:after&#123; box-sizing: border-box; content: ''; width: 50%; height: 100%; float: right; background: url("https://www.tuchuang001.com/images/2017/01/30/door.jpg"); border-left: 1px dashed black; /*设定发生变换的中心点 左右两个门分别赌赢左右轴*/ transform-origin: right center; transition: all 1s; &#125; div:hover:before&#123; transform: rotateY(-140deg); &#125; div:hover:after&#123; transform: rotateY(140deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果如下:]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5的进度条]]></title>
    <url>%2F2016%2F04%2F01%2Fnth-of-type(n)%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[xxx-of-type(n)选择器 一种迷之存在的选择器，真的有人会用这种选择器吗 E:first-of-type选择兄弟元素中的第一个E类型的元素li:first-of-type就是选择兄弟元素中第一个li元素 E:last-of-type就是选择兄弟元素中最后一个E类型的元素li:last-of-type就是选择兄弟元素中最后一个li元素 E:nth-of-type(n)就是选择兄弟元素中第n个E元素 和之前 nth-child(n)类似li:nth-of-type(5) 选择兄弟元素中第五个li元素 代码示例1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$别看我$&lt;/title&gt; &lt;style&gt; div li:first-of-type&#123; color: red; &#125; li:nth-of-type(2)&#123; color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;daf&lt;/li&gt; &lt;li&gt;adsf&lt;/li&gt; &lt;li&gt;adsf&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;li&gt;adsf&lt;/li&gt; &lt;li&gt;asdf&lt;/li&gt; &lt;li&gt;asdfas&lt;/li&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的进度条]]></title>
    <url>%2F2016%2F04%2F01%2F%E5%85%84%E5%BC%9F%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS3 兄弟选择器 CSS3 兄弟选择器 E~F 12345678910111213141516171819202122 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$别看我$&lt;/title&gt; &lt;style&gt; /*兄弟选择器*/ .p~h2&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;asdfasf&lt;/p&gt;&lt;p class="p"&gt;asdfasdf&lt;/p&gt;&lt;h2&gt;efasdf&lt;/h2&gt;&lt;p&gt;adsfasdf&lt;/p&gt;&lt;!--&lt;script src=jquery-3.1.1.js&gt;&lt;/script&gt;--&gt;&lt;script&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码中只有最后一个p标签被选中，兄弟选择器E~F只会选择 E 后面的兄弟元素F。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5新增的DOM扩展]]></title>
    <url>%2F2016%2F04%2F01%2FH5%E5%AF%B9DOM%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[H5对DOM的扩展 新增的选择器方法 ###querySelector()在括号内可以填写CSS选择器 类似于Jquery 但是只会匹配第一个对应的元素 querySelectorAll()同上 但是会选择到所有匹配的元素 (没有隐式迭代)123document.querySelector( 'li').style.backgroundColor = 'yellowgreen';document.querySelector('.hot').style.backgroundColor = 'red';document.querySelector('#eggWithmeat').style.backgroundColor = 'brown'; 增加的类名操作方法 dom中原来的类操作方法只有一个参数是className 可以进行简单的操作 是一个字符串 H5的类样属性为classList 是一个包装对象 类似于数组 但是有自己的方法 value 属性是和原来的className类似 数组的每个索引对应一个类名 length属性对应类的个数 obj.classList.add（） 添加类样式的方法 $中addClass obj.classList.remove() 删除类样式的方法 $中removeClass obj.classList.contains()检测是否有这个类样式 $中hasClass obj.classList.toggle() 如果没有就添加 有就删除 $中toggleClass自定义属性 在HTML 属性中 可以添加自定义属性 必须用data-进行开头 在DOM中访问时 需要用 对象.dataset.属性名或者对象.dataset[&quot;属性名&quot;]进行访问]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的进度条]]></title>
    <url>%2F2016%2F04%2F01%2F%E9%83%A8%E5%88%86%E4%BC%AA%E5%AF%B9%E8%B1%A1%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[伪对象选择器 和伪类选择器类似 placeholder 是在表单中提示输入内容的占位符input::placeholder{}修改Input标签中的默认提示文字 只会修改提示文字的样式 部分CSS属性可能不能使用 selection 指在浏览器中被选定的部分 比如用户要复制一段文字时先进行选定文字，这时候可以对已经选定的文字来进行修改p:selection{}选定的是在网页中被用户选择的P标签的内容 可以是动态变化的 浏览器前缀的问题由于以上两个属性在很多浏览器中都还只是在测试阶段,所以单纯的输入属性值可能样式是无法显示的，这时候为了获得浏览器的支持 需要在选择器之前写浏览器前缀 不同的浏览器有不同的前缀 -webkit- 谷歌 -ms- IE -moz- 火狐 -o- opera123input::-webkit-input-placeholder &#123; color:orange; &#125; before和after before和after分别是设置在对象的前后发生的内容我理解成是分别在元素的内部最前面和最后面生成的内容， 必须有属性content属性才能工作,content可以设置成空的字符串 默认是行内块元素可以在浏览器的elements选项里看到生成的元素 div的样式会影响before和after的样式div::before{content:&quot;before the div&quot;;}在div内容最前面before内容是before the div。用before和after做菜刀和滑板里面用了border-radius属性 设置边角的圆角大小 可以用百分比 或者px123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .knife &#123; width: 200px; height: 50px; margin: 0 auto; background-color: lightgray; position: relative; border-bottom-left-radius: 50px; border-bottom-right-radius: 5px; &#125; .knife::after &#123; content: ''; /**/ position: absolute; right: -100px; width: 100px; height: 15px; background-color: firebrick; color: white; font-size: 10px; text-align: center; &#125; .skate-board &#123; width: 200px; height: 10px; margin: 100px auto; background-color: yellowgreen; position: relative; &#125; /* 前轮 */ .skate-board::before &#123; /* 必须 */ content: ''; /* 定位之后 变为块了 才能够设置大小 */ position: absolute; width: 30px; height: 30px; top: 10px; left: 0px; background-color: black; /* */ /*border-radius: 10px;*/ /* 对于 宽高一样的元素 */ border-radius: 50%; &#125; /* 后轮 */ .skate-board::after &#123; /* 必须 */ content: ''; /* 定位之后 变为块了 才能够设置大小 */ position: absolute; width: 30px; height: 30px; top: 10px; right: 0px; background-color: black; border-radius: 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='knife'&gt;&lt;/div&gt; &lt;div class='skate-board'&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的兼容性]]></title>
    <url>%2F2016%2F04%2F01%2F%E8%80%81%E7%89%88%E6%9C%ACIE%E5%92%8CH5%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[老版本IE和H5的兼容问题 IE8是前端开发不可忽视的兼容性问题 如何在不支持H5的IE8中使用新标签 DOM方法为例 首先创建一个元素var ele=document.createElement(&quot;&quot;); 设置元素的样式 ele.style.display=&quot;block&quot;; 把元素添加到页面中 body.appendChild(ele);123var header=document.createElement("header"); header.style.display="block"; document.body.appendChild(header); 可以使用别人封装好的库 来在页面中直接使用H5新标签 1&lt;script src='js/html5shiv.min.js'&gt;&lt;/script&gt; IE8的兼容写法 使用编译器的快速写法 CC:IE6 然后tab展开 在两行的中间添加代码，这样只有在低于或等于你填写的版本时 这段代码才会执行12345 &lt;!--[if lte IE 6]&gt;&lt;script &gt; console.log("你的浏览器太LOW 赶快升级吧");&lt;/script&gt;&lt;![endif]--&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的新增表单]]></title>
    <url>%2F2016%2F04%2F01%2FH5%E4%B8%AD%E6%96%B0%E6%B7%BB%E5%8A%A0%E7%9A%84%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[H5中新添加的表单元素 H5中添加的新表单有有以下几种12345678910&lt;form action="#"&gt; &lt;input type="color"&gt; &lt;input type="date"&gt; &lt;label for=""&gt;请输入邮箱:&lt;/label&gt; &lt;input type="email" placeholder="请输入邮箱" autofocus&gt; &lt;input type="tel"&gt; &lt;input type="number"&gt; &lt;input type="search"&gt; &lt;input type="range" id='myRange'&gt;&lt;span id='output'&gt;0&lt;/span&gt; &lt;/form&gt; 新增的表单事件* onchange 在确定每次修改value之后触发 滑动滑块事件中会在鼠标松开后触发 * oninput 会在用户输入时候触发 滑块事件中 每当用户滑动就会触发 * oninvalid 会在用户输入的表单不合法时候触发事件 **这个事件中一般使用setCustomvalidity(&quot;&quot;);来设置输入错误时显示的提示语 ###滑块输入和滑块数值的显示例子12345var huakuai=document.getElementById("myRange"); huakuai.oninput=function () &#123; var val=this.value; document.getElementById("output").innerText=val; &#125;//配合上面代码块一起 ##新增表单的属性 &gt;新增的表单相比于传统的表单只是修改了部分特殊的显示或者其他特效，将原由的输入标签划分的更加细致 *required属性 这个表单必须要填 才能进行提交 *placeholder=“提示内容” 占位符 当你没有进行输入时 他会显示出灰色字符串 输入时消失 *pattern=“正则表达式” 他会按照你输入的正则表达式对表单value进行校验，校验失败则无法提交 不用写/^ $/。 可以配合invalid 事件 和setCustomvalidity()方法来修改浏览器默认样式进行提示。 ##新增加的表单标签 *效果类似于搜索框的单选框123456&lt;input type="text" list="foodlist" &gt; &lt;datalist id='foodlist'&gt; &lt;option value="vegetable"&gt;西兰花&lt;/option&gt; &lt;option value="beef"&gt;牛肉&lt;/option&gt; &lt;option value="rice"&gt;泰国香米&lt;/option&gt; &lt;/datalist&gt; outpu标签 语义化标签 输出的意思 Keygen标签 对表单进行加密 以上两者都不推荐使用 123&lt;output&gt;123&lt;/output&gt; &lt;br&gt; &lt;keygen name=""&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的进度条]]></title>
    <url>%2F2016%2F04%2F01%2FC3%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[C3阴影效果 文字阴影 text-shadowtext-shadow的参数 第一个参数是水平x轴的阴影方向 长度 第二个参数是垂直方向y轴的阴影方向和长度 第三个参数是模糊值 设置阴影的模糊效果 不允许设置负数 第四个参数是阴影的颜色 使用逗号分隔后可以设置另外一个阴影，文字可以同时有许多个阴影。p:text-shadow:3px 3px red，-1px -1px yellow给p标签文字的阴影 右3px 下3px 红色的阴影 和左1px 上1px 黄色阴影。盒子阴影 box-shadow 和文字阴影类似 不重复介绍##]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的进度条]]></title>
    <url>%2F2016%2F04%2F01%2Fbox-sizing%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[C3box-sizing属性 这个属性只有两个值，分别是border-box,content-box; 属性值的介绍 border-box属性是指，给当前盒子设定的宽度高度包括了Border 也就是如果宽度设置为50px，有1bpx的border那么会将盒子的宽度改成48px。类似border属性的还有padding属性。都不会将盒子撑大。 content-box 默认值，也就是给当前盒子设置的宽高对应的是内容的宽高。##用border-sizing属性来修改简易日历。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul &#123; list-style: none; margin: 100px auto; padding: 0; width: 420px; background-color: hotpink; overflow: hidden; &#125; li &#123; width: 60px; height: 60px; /*border: 1px solid gray;*/ border-top:1px solid gray; border-left: 1px solid gray; float: left; text-align: center; line-height: 60px; font-size: 20px; font-family: "微软雅黑"; /* 设置盒子模型属性 保证 元素 自身的尺寸 不变 通过压缩内容来实现 */ box-sizing: border-box; &#125; li:nth-child(7n)&#123; border-right: 1px solid gray; &#125; li:nth-child(n+22)&#123; border-bottom: 1px solid gray; &#125; li:nth-child(n+29)&#123; border-top:none; &#125; li:nth-last-child(1)&#123; border-right: 1px solid gray; width: 61px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;12&lt;/li&gt; &lt;li&gt;13&lt;/li&gt; &lt;li&gt;14&lt;/li&gt; &lt;li&gt;15&lt;/li&gt; &lt;li&gt;16&lt;/li&gt; &lt;li&gt;17&lt;/li&gt; &lt;li&gt;18&lt;/li&gt; &lt;li&gt;19&lt;/li&gt; &lt;li&gt;20&lt;/li&gt; &lt;li&gt;21&lt;/li&gt; &lt;li&gt;22&lt;/li&gt; &lt;li&gt;23&lt;/li&gt; &lt;li&gt;24&lt;/li&gt; &lt;li&gt;25&lt;/li&gt; &lt;li&gt;26&lt;/li&gt; &lt;li&gt;27&lt;/li&gt; &lt;li&gt;28&lt;/li&gt; &lt;li&gt;29&lt;/li&gt; &lt;li&gt;30&lt;/li&gt; &lt;li&gt;31&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的进度条]]></title>
    <url>%2F2016%2F04%2F01%2FH5%E4%B8%AD%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[H5中的进度条 ##自带的进度条 &gt;因为在不同的浏览器中进度条的样式不同 所以在开发中很少使用这两种进度条只进行简单的介绍 12345&lt;h2&gt;进度条1&lt;/h2&gt; &lt;meter value=".5"&gt;&lt;/meter&gt; &lt;h2&gt;进度条2&lt;/h2&gt; &lt;!-- progress 如果要显示 百分比的精度 需要设置 value 跟max --&gt; &lt;progress value="50" max="100"&gt;&lt;/progress&gt; ##自定义的进度条1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .progress&#123; border: 1px solid #000; height: 30px; width:200px; &#125; .step&#123; height: 100%; width:50%; background-color: hotpink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;自定义进度条&lt;/h1&gt; &lt;div class="progress"&gt; &lt;div class="step" id='step'&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type="range" id='range' &gt;&lt;/body&gt;&lt;/html&gt; ###自定义进度条的小案例 随着滑块移动 改变进度条12345678910111213141516// 先获取需要修改的dom元素 var stepDom = document.getElementById('step'); // 滑动滑块 会一直触发 document.getElementById('range').oninput = function()&#123; var value = this.value; // 超过了 50 变黄 if(value&gt;50)&#123; stepDom.style.backgroundColor ='yellow'; &#125;else&#123; // 小于50变绿 stepDom.style.backgroundColor ='green'; &#125; // 修改进度条的 width属性 stepDom.style.width = value +'%'; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的进度条]]></title>
    <url>%2F2016%2F04%2F01%2FC3%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS3新增的常用伪类选择器 CSS3增加了许多新的伪类选择器 但部分浏览器兼容较差 :first-child选择第一个子元素，但是区别于jQuery的选择器，first-child会选择父元素的第一个子元素，其实也就是兄弟元素的第一个冒号前最好写上标签要不然将会选择所有的元素 :last-child同上选择最后一个子(xiong di)元素 1234li:first-child,li:last-child&#123; color:red;&#125;/*第一个最后一个Li标签的文字都会变红色*/ :nth-child(n) 如果n填写的是数字那么会选择父元素的子元素的第n个元素 第一个标签对应的是数字1 还可以在括号内填写n为参数的算式，n会从0开始累加，直到超过范围，但是算式中第一项必须含有n 例如:nth-child(2n)代表选择为偶数的标签 nth-child(2n-1)代表选择为奇数的标签 nth-child(n+5)代表从第五项开始选择到最后一项##简单日历的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$别看我$&lt;/title&gt; &lt;style&gt; li&#123; padding:0; display: block; float: left; width: 58px; height: 60px; list-style: none; border-left: 1px solid black ; border-top: 1px solid black ; text-align: center; line-height: 60px; &#125; ul&#123; padding: 0; width: 420px; height: 500px; margin:0 auto; background-color: hotpink; &#125; li:nth-child(n+22)&#123; border-bottom: 1px solid black ; &#125; li:nth-child(n+29)&#123; border-top:none; &#125; li:nth-child(31)&#123; border-right:1px solid black ; &#125; li:nth-child(7n-1)&#123; background-color: red; &#125; li:nth-child(7n)&#123; border-right:1px solid black ; background-color: crimson; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;12&lt;/li&gt; &lt;li&gt;13&lt;/li&gt; &lt;li&gt;14&lt;/li&gt; &lt;li&gt;15&lt;/li&gt; &lt;li&gt;16&lt;/li&gt; &lt;li&gt;17&lt;/li&gt; &lt;li&gt;18&lt;/li&gt; &lt;li&gt;19&lt;/li&gt; &lt;li&gt;20&lt;/li&gt; &lt;li&gt;21&lt;/li&gt; &lt;li&gt;22&lt;/li&gt; &lt;li&gt;23&lt;/li&gt; &lt;li&gt;24&lt;/li&gt; &lt;li&gt;25&lt;/li&gt; &lt;li&gt;26&lt;/li&gt; &lt;li&gt;27&lt;/li&gt; &lt;li&gt;28&lt;/li&gt; &lt;li&gt;29&lt;/li&gt; &lt;li&gt;30&lt;/li&gt; &lt;li&gt;31&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; ![日历1]https://www.tuchuang001.com/images/2017/01/25/data1.png)]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的进度条]]></title>
    <url>%2F2016%2F04%2F01%2F%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CCS3 属性选择器 和jquery类似 C3中也有不少属性选择器了。 [att] 表示选择具有att属性的元素 att可以是自定义属性 123li[index]&#123; color:red;&#125; [att~=”val”] att属性中有用空格分开的val属性 123li[class~=fruit]&#123; backgroundColor:&quot;green&quot;;&#125; [att^=”val”] att属性的值以val开头 1li[class^="icon-"]&#123;&#125; [att$=”val”] att属性的值以val结束 1[class$="gg]&#123;&#125; [att*=”val] att属性中包含字符串w 123[class*="z"]&#123; fontSize:20px;&#125; 可以结合以下代码进行测试12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$别看我$&lt;/title&gt; &lt;style&gt; [index]&#123; color: red; &#125; [class*="z"]&#123; font-size:20px; &#125; li[class^=icon]&#123; color: blue; &#125; li[class$=gg]&#123; background-color: chocolate; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li index="5"&gt;Lorem ipsum dolor sit.&lt;/li&gt; &lt;li class="fruit"&gt;apple&lt;/li&gt; &lt;li class="icon-gg"&gt;Lorem ipsum dolor sit.3&lt;/li&gt; &lt;li class="zr"&gt;Lorem ipsum dolor sit.4&lt;/li&gt; &lt;li class="zl"&gt;Lorem ipsum dolor sit.5&lt;/li&gt; &lt;li&gt;Lorem ipsum dolor sit.6&lt;/li&gt;&lt;/ul&gt;&lt;script src=jquery-3.1.1.js&gt;&lt;/script&gt;&lt;script&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的多媒体标签]]></title>
    <url>%2F2016%2F04%2F01%2F%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E7%AD%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[多媒体标签的基本使用 多媒体标签就是视频和音频 ##视频标签 VIDEO video 标签有以下几个常用的属性 controls 控制器 在视频的下方显示暂停 音量等 按钮 不同的浏览器样式会有区别 loop 循环播放 播放结束后再次从头播放height width 视频标签的宽高 为了保证视频的播放效果 要保持视频的宽高比 video 标签内部可以嵌套source 标签来制定多个视频地址 浏览器会由上到下逐个访问，知道找到能成功播放的视频audio 音频标签同上1&lt;video src="movie/movie01.mp4" controls autoplay loop width="200px" height="500px"&gt;&lt;/video&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(11)%2F</url>
    <content type="text"><![CDATA[闲聊学习编程注意点: 理解 总结 复习方向 移动web pc网站 混合开发(原生开发Android.ios+web开发) node.js做后端 可以作为独立的技能 还有很多附加的内容 网络 服务器 数据库 作为一个专业的前端，也必须对node有了解，作为工具来使用。 桌面程序 (electron) 很少作为一个独立的工作。复习 javascript 是一门编程语言 javascript的运行引擎 浏览器-&gt;内核-&gt;(渲染引擎 js引擎) javascript 核心是ecma dom bom javascript对dom节点的增删改查 JS数据类型 基本类型 number string boolan null undefined 引用类型 object(Array Date Math RegExp Function Object 包装类(Number String Boolean Error XMLHttpRequest )) Math比较特别。 基本类型和引用类型之间的差别。存储方式不同，基本类型数据存储在stack,引用类型存储在heap堆。基本类型传递的是值，引用类型传递的是内存的地址。面向对象开始异常处理程序一步一步的执行，当遇到错误时，后面的程序将不会执行。可以用try{}catch(e) 来捕获异常，当程序发生错误的时候，就会捕获错误，e就是错误，后面的程序也会继续执行。 屏蔽底层的报错细节，给用户一个更好的提示。 e有两个常用的属性 messge错误的原因，name错误的l类型。12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; try &#123; throw new Error("has error"); console.log("我不会被执行"); &#125;catch(e)&#123; console.dir(e); console.log(e.message); console.log(e.name); console.log(arguments); &#125;finally&#123; console.log(无论怎么样我都会执行); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当try的内部发生错误的时候，大括号内的代码将不会在执行，直接跳入到catch中.finally无论如何都会执行在最后。 访问对象属性的两种方式一种是对象.属性 一种是对象[]属性，中括号里面可以放变量。 对象的创建 通过构造函数new 对象字面量 只能创建实例 基于Objec1234var obj=&#123; name:zhangsan, gender:'male'&#125;; 构造函数实例化的过程中都做了 什么 开辟内存用来存储实例中的数据 用this指向当前的区域 通过this向该区域存放数据 返回this 也就是说构造函数中的this指向的就是当前的实例对象。实例方法中的this，指向方法的调用者，实际上就是实例对象本身。构造函数虽然没有返回值，但是返回了实例，隐式返回值就是this。如果有显示返回，返回基本数据类型，那么和返回等效，返回引用类型的话，会被执行。 对象的本质就是无序的键值对的集合。 原型在构造函数中假设存储了一个常量，那么所有的实例，都会有一个单独的这个属性，存储的是相同的内容，造成浪费，为了解决这个问题，设计了原型。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function Person(name,age)&#123; this.name=name; this.age=age; &#125; var p1=new Person('tom','13'); var p2=new Person('jerry','11'); Person.prototype.flag=true; console.log(p1.flag);//true //这个属性会被共享到所有实例。 //所有的函数都有原型Prototype &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; prototype存在于所有构造函数实例对象中，指向构造方法的prototype指向的位置。该属性不是标准属性，也就是说虽然能被打印，但是写程序时无法进行操作，是浏览器内部使用的，自己定义的名称。所有的函数都有原型Prototype,该属性本质也是对象(object的实例)。实现实例对象之间数据的共享。 面向对象什么是面向对象?面向对象是一种编程模式，就是以对象的方式写代码。 面向过程编程模式的缺点，团队开发容易产生命名冲突。不方便代码的重用。 this 的场景 构造函数中的this 指向实例对象. 原型方法中的this 指向实例对象. 事件函数中的this 指向绑定事件的对象dom typeoftypeof是一个运算符。会显示出以下几个类型 number string boolean undefined object function null会显示是object 对象中属性的判断 in 判断对象中和原型链中是否存在某个属性 hasOwnProperty()判断是否在实例对象中。1234if('a' in window)&#123; var a=123; console.log(a);//123 会打印出123&#125; JS中全局作用域中的变量和函数都是window的属性，JS中没有块级作用域，JS中存在变量提升，所以if语句判断为真。1234567function Foo(info)&#123; this.info=info;&#125;var foo=new Foo('hello');Foo.prototype.flage=true;console.log('flag' in foo) ;//tureconsole.log(foo.hasOwnProperty('info'));//false]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(2)%2F</url>
    <content type="text"><![CDATA[反馈反馈反馈反馈对象对象对象对象 本地对象 独立于宿主环境的对象 (独立于浏览器的对象，没有浏览器也会有的对象 Array String Date Number Boolean RegExp Function Object Error) 内置对象 Math Global (global 在浏览器中是window) 宿主对象 浏览器提供的对象 DOM对象 BOM对象 自定义对象类数组delete 删除对象的属性12var arr=[1,23123,1421,123;delete arr[0];//第一个元素就会被删除 使用delete删除全局变量的时候，只能删除没有var声明的变量。 数组也是一个对象，可以向数组添加属性，当添加数值为索引的属性的时候，会改变数组的长度，数组的长度根据最后一个索引为数字的元素计算。 类数组就是模仿数组，也设置索引为数字，有length的属性。但是类数组是无法使用数组的方法的。为了使用数组的方法，我们可以把类数组转换成数组，通过slice方法。1234567var obj=&#123; 0:0, 1:1, 2,2, length:3&#125;Array.prototype.slice.apply(obj,0); 注意obj中的length会影响apply方法的转化。]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2Fday4%2F</url>
    <content type="text"><![CDATA[day4动态组件可以使用保留好的components元素，再用v-bind来动态绑定他的is属性，可以让多个组件共同绑定这个标签 1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; currentView: 'home' &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;) 123&lt;component v-bind:is="currentView"&gt; &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;&lt;/component&gt; keep alive当一个动态组件要多次来回切换同样几个组件的时候，可以用kekp-alive元素来包裹，这样可以缓存好原来的状态。 杂项编写可复用组件在编写一个组件的时候，要充分的考虑到组件的可复用性。一个组件的主要api有 props 允许外部环境传递数据给组件内部 Events 允许组件内部触发外部的事件 slots润徐外部环境将额外的内容加载到组件内部子组件索引当需要在js中直接访问子组件，可以通过ref属性123&lt;div id="parent"&gt; &lt;user-profile ref="profile"&gt;&lt;/user-profile&gt;&lt;/div&gt; 123var parent = new Vue(&#123; el: '#parent' &#125;)// 访问子组件var child = parent.$refs.profile 当ref和v-for一起使用的时候，ref是一个数组或者对象，包含着对应的子组件。他并不是响应式的，尽量避免在模板或者计算属性中使用。 异步加载在有些时候需要异步的加载文件Vue可以把他们缓存起来，方便下次渲染 12345678Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // Pass the component definition to the resolve callback resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) 组件的命名在JS中Vue不关心你的命名形式，但是在html中必须遵守标准，用小写加横杠。 组件的递归一个组件是可以调用自己的，这样就会造成递归，所以必须要有终止的条件，比如v-if。 深入响应式原理如何追踪变化当你把一个js对象传入data的时候，Vue会对他设置setter和getter。 每个组件都有对应的watcher实例对象，他们会在组件渲染的过程中把他们记录为依赖，之后当依赖项的setter被调用的时候，会通知wacher重新计算，从而导致更新。 变化检测中存在的问题如上述原理，当你给数据增加新元素的时候，setter是检测不到的，所以要使用Vue.set方法。 所以在声明响应式的属性的时候，尽量要写全，避免之后追加，也可以先声明一个空的数据。 更新和渲染页面的过程是异步的。 单元素/组件的过渡Vue提供了transition的封装组件，在下列情形中，可以给任何元素的组件添加entering/leaving过渡 条件渲染 v-if 条件展示 v-show 动态组件 组件跟节点 在要使用过渡效果的元素上使用transition标签包裹设置name属性来寻找对应的类名。 过渡的类名 v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。 v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。 v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。 用过渡元素的name属性来替换掉v就可以写入css了 小例子 1234567891011121314/*设置过渡进入的效果*/ .slide-fade-enter-active &#123; transition: all .3s ease; &#125; /*设置过渡出的效果*/ .slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); &#125; /*一般过渡的起始状态和结束状态可以用enter 和leave-active设置*/ .slide-fade-enter, .slide-fade-leave-active &#123; transform: translateX(10px); opacity: 0; &#125; 123456new Vue(&#123; el: '#example-1', data: &#123; show: true &#125; &#125;) 12345678&lt;div id="example-1"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;transition name="slide-fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; CSS动画CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。 自定义过渡类名可以在过渡类名的后面加上-class，这个自己使用的类样式名优先于其他过渡样式，配合CSS动画库使用十分方便。 过渡事件可以设定JS钩子，也就是回调函数，事件。 123456789101112&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 需要注意的是在enter和leave中，第二个参数done函数必须被调用一次。才能继续进行。尤其是仅用js过渡的动画，当你想仅用js来操作的时候可以设置v-bind:css=&#39;false&#39;]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2Fday3%2F</url>
    <content type="text"><![CDATA[组件props单向数据流上例中的数据传递，只能是从外到内，而不能从内到外，是单项的。内部不可以对数据进行修改。 一般我们修改子组件中的props数据，多半是因为 prop 作为初始值传入后，子组件想把它当作局部数据来用； prop 作为初始值传入，由子组件处理成其它数据输出 解决这个两个问题要用到不同的方式。可以使用一个局部变量，来保存这个属性，操作时访问这个局部变量。 1234props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 可以使用计算属性，处理porps值 123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意当props是一个引用类型的时候， props验证当你的组件给第三个人使用的时候，可能就需要Props的验证了，判断传入的数据是否符合规格。这是props不再时一个数组了，需要是一个对象。12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组／对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) ## 自定义事件我们已经知道了父组件可以使用props来给子组件传递数据，那么子组件怎么传递数据给父组件呢，就要用到自定义事件。Vue实现了事件接口 $on(type)监听事件，$emit()触发事件虽然和addeventlistern类似，但是是有区别的。$on不能监听到子组件抛出的事件，需要用v-on12345678910111213141516171819202122232425262728293031323334353637&lt;div id="app"&gt; &#123;&#123;counter&#125;&#125; &lt;br&gt; &lt;child v-on:count="couterTotal"&gt; &lt;/child&gt; &lt;child v-on:count="couterTotal"&gt; &lt;/child&gt; &lt;child v-on:count="couterTotal"&gt; &lt;/child&gt; &lt;/div&gt; &lt;script src="../vue.js"&gt; &lt;/script&gt; &lt;script&gt; Vue.component('child', &#123; template:'&lt;button v-on:click="count"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data:function()&#123; return &#123; counter : 0 &#125; &#125;, methods:&#123; count: function ()&#123; this.counter ++; this.$emit('count'); &#125; &#125; &#125;) var app = new Vue(&#123; el: "#app", methods:&#123; couterTotal:function ()&#123; this.counter++; &#125; &#125;, data:&#123; counter:0 &#125; &#125;) &lt;/script&gt; 在这里，其实这两者之间的关系是已经完全解耦的，内外部有隔断的。 solt分发内容我们在使用组件的时候，可能会嵌套配合使用。1234&lt;app&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;app-footer&gt;&lt;/app-footer&gt;&lt;/app&gt; 组件可能有自己的模板，而父组件和子组件的模板就产生了冲突，这时候就产生了solt分发内容。 编译作用域组件内部的作用域是该组件，组件标签上的内容作用域是父组件， 单个solt在子组件中可以定义solt标签，标签内的内容都是备用的内容，当嵌套到其他组件时，该部分内容会被覆盖。假设my-componnet组件中定义如下模板123456&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt; 父组件的模板如下1234567&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 渲染的结果将会是12345678&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名slot具名就是有名字，hasname。可以在子模板，父模板中同时定义slot标签，然后通过name的对应关系来指定渲染的位置。当slot标签没有name时候，默认会把父元素中没有找到对应name部分的元素渲染进来。app-layout的模板如下1234567891011&lt;div class="container"&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 父组件的渲染模板如下123456&lt;app-layout&gt; &lt;h1 slot="header"&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot="footer"&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 渲染的结果就是123456789101112&lt;div class="container"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 作用域插槽就是在定义子组件的时候在slot上声明一个自定义属性，在父组件中用一个template标签的scope标签来接收这个字标签的props数据是一个对象。template会替换掉已经渲染的元素12345678910111213141516171819202122 &lt;div id="app"&gt; &lt;div&gt; &lt;childa&gt; &lt;template scope="props"&gt; &lt;span&gt;Hello from parent!&lt;/span&gt; &lt;span&gt;&#123;&#123;props.text&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/childa&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="../vue.js"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('childa', &#123; template: '&lt;div&gt; &lt;slot text="hello form child" style="color:red"&gt; &lt;/slot&gt;&lt;/div&gt;' &#125;); var app = new Vue(&#123; el: "#app" &#125;);&lt;/script&gt; 这个结果会渲染出两个语句。template标签也可以设置slot属性，对应的值就可以看成slot的Name属性]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2Fday2%2F</url>
    <content type="text"><![CDATA[Class与Style绑定绑定HTML Class对象语法使用123456还可以用增强式的写法```v-bind:class=&quot;&#123;height:ischeck&#125;&quot;```会根据ischeck的布尔属性，来判断是否添加height。```html&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt; 数据如下1234data: &#123; isActive: true, hasError: false&#125; 会被渲染成1&lt;div class="static active"&gt;&lt;/div&gt; 当data里的两个属性发生变化的时候，页面也会刷新。 也可以直接把绑定的这个对象直接写在data中123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 所以我们也可以绑定到计算属性返回的对象。 数组语法可以绑定对象，那么也可以绑定类似的数组1&lt;div v-bind:class="[activeClass, errorClass]"&gt; 1234data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 会被渲染成1&lt;div class="active text-danger"&gt;&lt;/div&gt; 在组件上使用组件上类似于html的普通类样式，和绑定的数据时共存的，不会产生冲突。 内联样式的绑定当使用一些CSS的新特性的时候，插件会自动添加前缀！ 对象的写法可以使用对象的写法，CSS内部可以使用驼峰命名法或者-连接 短横分隔命名。 建议直接绑定到一个对象中1&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 数组语法也可以使用数组语法，数组中的每一个变量都是一个对象。 条件渲染v-ifv-if在之前已经介绍过。 v-if也可以在中使用 配合v-if的还有v-else和v-else-if 不进行详尽的介绍了 ##keykey可以管理可复用元素的渲染。123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username"&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address"&gt; &lt;/template&gt; &lt;input type="button" :value="loginType" @click='change'&gt;&lt;/div&gt;&lt;script src="../vue.js"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; loginType:'username' &#125;, methods:&#123; change: function ()&#123; if(vm.loginType=='username')&#123; vm.loginType='email'; console.log(this.loginType) &#125;else&#123; vm.loginType='username' &#125; &#125; &#125;&#125;)&lt;/script&gt; 如果点击按钮切换模板的时候，input中的内容不会被修改，是因为vue认为这两个输入框内容是一致的 只是会修改他的placeholder。这时可以用自定义属性key来区分12345678&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt; v-show决定一个元素是否被显示，修改的是display元素。v-if是惰性的，只有在条件被改变的时候，才会重新渲染，而v-show是每次都会被渲染. v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 列表渲染v-for大部分功能和v-if类似。可以便利数组，遍历对象。另外还有 整数迭代123&lt;div&gt; &lt;span v-for="n in 10"&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;&lt;/div&gt; 渲染的结果是从0到10 组件和v-forv-for 可以在组件中使用，因为组件有一套自己的作用域，当调用vm中的数据时，是不可以直接获取到的，可以配合Props来传递数据。 key和v-if一样,v-for也有类似的缓存机制，当渲染已经存在的元素时，如果数据项的顺序被改变，Vue是不会移动dom元素来进行匹配的，也可以用:key来设置每次循环的key，理想情况下每个key都不一致。比如可以如下设置123&lt;div v-for="item in items" :key="item.id"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 变异方法因为直接操作数组的时候，数组的内存地址并没有改变，不会触发geter和seter所以无法检测。为了检测到Vue提供了以下的编译方法。 push() pop() shift() unshift() splice() sort() reverse()这些方法会修改数组，从而导致重新渲染filter(), concat(), slice() 这些方法虽然返回数组，但是不会修改原数组。 当用一个新数组替换原数组的时候，并不是丢弃当前的dom元素重新渲染，而是采用了内部优化手段。 注意当使用下面这种修改方式的时候，不会触发页面的渲染= newValue```12```vm.items.length = newLength 为了提供这种修改的方式Vue提供了下面的方法 indexOfItem, newValue)```1- ```example1.items.splice(indexOfItem, 1, newValue) 修改.lenght可以用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748## v-for 配合计算属性或者方法v-for 可以配合计算属性或者方法来使用，用来进行排序，过滤等等操作。# 事件处理器## 监听事件可以用v-on来监听dom元素的事件，函数体可以直接写在冒号里，this.可以省略，可以传入参数$event代表传入实践对象。## 事件修饰符加在事件名type的后面- .stop 阻止事件冒泡- .prevent 阻止事件的默认事件- .capture 使用事件捕获模式- .self 只有事件源头是这个元素本身，才会触发- .once 只触发一次## 按键修饰符可以给按键事件绑定的修饰符，```&lt;input v-on:keyup.13=&quot;submit&quot;&gt;```只有在键值是13的时候才会触发submit。Vue预设了一些常用的键值，可以直接调用，存在Vue.config.keyCodes.下- .enter- .tab- .delete (捕获 “删除” 和 “退格” 键)- .esc- .space- .up- .down- .left- .right- .ctrl- .alt- .shift- .meta- meta媒体按键，在不同的系统中可能是不同的按键。windows下可能是win#表单控件绑定很多表单，感觉没必要挨个说，v-model可以绑定一个控件的value到一个数据上。## 修饰符- .lazy 只有在值发生改变的时候触发，而不是每次按键触发。- .number 会将value转换成数字- .trim 可以去掉两侧的空格# 组件&gt; 组件是Vue最强大的功能## 注册注册组件要使用Vue.component函数，第一个参数的组件的标签名，第二个参数是一个对象，对象里包含props,template等属性。自定义标签最好符合W3C标准，也就是小写加-```html&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 1234567Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;) 局部注册当不需要在全局范围内注册组建时，可以在一个Vue实例化的参数中声明。 1234567891011var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父模板可用 'my-component': Child &#125;&#125;) DOM模板解析当你的自定义组建在一些标签内使用时，可能受到限制，因为Vue只能在浏览器按照标准化解析之后才能操作DOM，但是一些标签ul,ol等存在着限制，所以可以用Is标签来定义组件。 12 data必须是函数组件中的data必须是一个函数，这种方式的目的是，通过函数的局部变量，来个每个实例一个属性。 12345&lt;div id="example-2"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt; 1234567891011121314var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 技术上 data 的确是一个函数了，因此 Vue 不会警告， // 但是我们返回给每个组件的实例的却引用了同一个data对象 data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;) data函数的返回值将作为data来存储。 自定义属性和驼峰命名因为HTML对大小写是不敏感的，所以在html中要用小写字母-符号连接的方式。 动态props12345678910111213141516171819202122232425262728&lt;div id="app"&gt; &lt;div&gt; &lt;input v-model="parentMsg"&gt; &lt;br&gt; &lt;child v-bind:my-message="parentMsg"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="../vue.js"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('child', &#123; // camelCase in JavaScript props: ['myMessage'], template:'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;', data:function()&#123; return &#123; // myMessage:"hahahah" &#125; &#125; &#125;) var app = new Vue(&#123; el: "#app", data:&#123; parentMsg:"hahahah" &#125; &#125;)&lt;/script&gt; 组件的模板必须渲染一个标签，这里将parentMsg绑定到了子组件的props上。实现了关联。 同时注意子组件定义的自定义属性上使用了v-bind，不然只是复制了一个字面量的值。]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2Fday1%2F</url>
    <content type="text"><![CDATA[day1没了好多，手滑删掉了 实例和data实例会代理data 1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; data: data&#125;)vm.a === data.a // -&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // -&gt; 2// ... 反之亦然data.a = 3vm.a // -&gt; 3 Vue实例中也暴露的一些方法，为了防止变量命名冲突，所有暴露的属性方法都用$开头 12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)vm.$data === data // -&gt; truevm.$el === document.getElementById('example') // -&gt; true// $watch 是一个实例方法vm.$watch('a', function (newVal, oldVal) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 实例化的生命周期。一个Vue在被实例化的过程为了方便管理，分成不同的周期，同时插入了回调函数。 1234567891011var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;)// -&gt; "a is: 1" 模板引擎文本可以使用最常见的语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647也可以使用v-once 指令，来设置插值，他的值不会随着改变。但是这样会影响一个节点的其他的数据绑定。//目前不知道影响在什么地方## html代码可以使用命令 v-html 来完成，但是要千万小心，小心XXS攻击。每个&#123;&#123;&#125;&#125;(绑定)中只能包含单个表达式，变量的声明，和流控制语句if都不会生效，要使用三元表达式。全局变量只能访问白名单中的变量，Math和Date等，不能使用用户自己的全局变量。## 指令- v-if 决定是否插入这个元素，根据绑定数据类型的布尔值来判断。### 含参数的指令有的指令需要配合参数来使用比如- ```v-bind:href=&quot;url&quot;```把标签的href属性绑定到数据url上。- ```v-on:click=&quot;do&quot;```这里的do是函数，会在元素click事件触发时候被调用。### 修饰符- ```&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;```修饰符在参数之后，.prevent表示对阻止事件的默认行为。### 过滤器Vue允许自定义过滤器，可以操作一些文本。用跟在管道符后面，过滤器可以用在v-bind中或者胡子中。过滤器也可以接受参数，但是第一个参数被设定为管道符之前的文本数据，在调用时传入的参数将会作为第二个参数开始，过滤器也可以进行嵌套。过滤器在app中使用filters属性定义。```html &lt;div id=&quot;app&quot; &gt; &lt;span &gt;&#123;&#123; message | capUp&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm=new Vue(&#123; el:&apos;#app&apos;, data:&#123; message:&quot;hello&quot; &#125;, filters:&#123; capUp: function (value) &#123; value=value.toString(); var str=value.charAt(0).toUpperCase()+value.slice(1); console.dir(str); return str; &#125; &#125; &#125;); &lt;/script&gt; 缩写为了简化使用，将最常用的两个命令v-bind和v-on设置了简写12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;&lt;/a&gt;&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;&lt;/a&gt; 计算属性有的属性需要很复杂的操作才能写入网页，当这些逻辑都写在模板引擎中的时候，会变得非常难以维护，所以抽离除了属性计算这个功能。计算函数声明在computed属性中，在模板引擎中可以当做字符串调用，并且如果依赖其他的数据，在其他的数据更新的时候，这个数据也会被更新。1234567891011121314151617181920 &lt;div id="app" &gt;&lt;span &gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;h3&gt;&#123;&#123; remessage&#125;&#125;&lt;/h3&gt;&lt;input type="text" v-model="message" name="" value=""&gt; &lt;/div&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app', data:&#123; message:"我为什么总要被反过来" &#125;, computed:&#123; remessage: function () &#123; return this.message.split("").reverse().join(""); &#125; &#125; &#125;); &lt;/script&gt; 这个功能会实现到修改文本框的内容时，正序倒叙的内容都改变。 计算属性的缓存计算属性是存在缓存机制的，并不是每一次重新渲染都要执行计算缓存的函数，当依赖的数据没有发生改变的时候，是不会执行这个函数的。 计算属性的 get 和set计算属性平时默认只有get，但是也可以设置set12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 当执行vm.fullname=”‘时set函数将会被调用，那两个值也将会被更新。 观察者watcherwatcher也能观察到数据的改动，但是相比于计算属性，更适合执行异步操作，或者开销较大的操作。]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[反馈DOM对象也是一个标准的对象，原型链比较长 HTMLSpanElements&gt;HTMLElement&gt;Element&gt;Node&gt;EventTarget&gt;Object Function 所有的函数都是Function的实例 Function也是一个函数 通过以上两条所以有以下结论，Fuction是自己的实例是自己的构造函数。12 console.log(Function.prototype===Function.__proto__);//true Function.prototype.proto指向Object的原型。 函数的三种角色 构造函数 普通函数 函数作为对象 函数到底是什么角色取决于调用方式。 new foo() 构造函数 foo() 普通函数 prototype属性就没什么用 foo.info=”haha” 对象 函数都是对象，但是对象不一定是函数 定义函数 系统函数 在不同的语言中名字可能不太一样，系统函数，类库，库函数等等。 自定义函数 函数声明 1function foo()&#123;&#125; 函数表达式 1var x=function()&#123;&#125; new Function() 12var fn1=new Function();//Function的参数中可以添加参数，最后一个参数写函数体，前面的参数写参数。 函数声明是在预解析阶段创建的，函数表达式是在代码执行阶段创建的。 函数声明只能在全局或者函数内部定义，而函数表达式只能在表达式中，出现。 调用函数调用方法调用函数的方法，函数中的this指向，取决于函数的调用方式。 构造函数 new调用 普通方式 对象方法 call applythis 构造函数中的this指向实例对象 原型方法中this指向实例 非严格模式下，this指向window，严格模式下指向Undefined 对象方法中，this就是方法的调用者。 事件方法中的this指定的是绑定事件的对象。多数情况下是DOM 定是函数中的this指向window call apply bind所调用的函数中的this，就是第第一参数，该参数必须是引用类型。 ES5添加了bind特性，bind改变函数内部this的指向的时候不调用函数，bind会有一个返回值，返回改变之后的新函数。 高级函数 作为参数的函数 作为返回值的函数()]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(10)%2F</url>
    <content type="text"><![CDATA[衍生的小问题对象的比较==12console.log(!![]);//tureconsole.log([]==false);//ture 看似上面两条语句是矛盾的，[]单独转换成布尔值的时候是true，为什么和false比较的时候就是false了？？？？事实上，空数组和布尔值进行比较的时候会将两者都转成数字在进行比较，也就是说实际执行的是以下的代码。 ture—&gt;1 false–&gt;0 []—-&gt;0123console.log(Number([].toString())==false);//0==0 对象和布尔值的比较会把对象转换成字符串，再转化成数字进行比较(value of) 有些方法会使用toString(如日期对象)，自定义的类会使用toString。[]转字符串转数字是0 。{}转换成字符串是字母，转成数字是NaN。 window和变量的提升123456if('a' in window)&#123; a=123; console.log(a)&#125;else&#123; console.log(false);//false&#125; 虽然在作用域内给a赋值，但是没有var，a不会被预解析。123456if( a in window)&#123; var a=123; console.log(a) //123 &#125;else&#123; console.log(false) &#125; 这段代码去掉判断语句中的单引号后会打印123。这是因为a被预解析，但判断语句执行时并没有被赋值，判断语句中失去了双引号a是一个值为undefined的变量。而window中是存在undefined这个属性的。所以会执行条件里的语句。 在早起的浏览器中，window.undefined的值undefined是可以被修改的，这会产生很多的其他问题。在jquery中为了解决这个问题使用了以下的方法。123(function(a,undefined)&#123;&#125;)(123); 指定了许多参数的函数，最后一个形参是undefined，而没有传入这个实参。这样在函数内部使用undefined的时候会使用未被定义的参数，屏蔽了全局变量Undefined。 复习 构造函数,实例对象，原型之间的关系。 构造函数中都有原型属性prototype,改属性本质也是一个对象。 原型对象中都有一个属性constructor，指向构造函数. 实例中都有一个属性prototype,该属性不是标准属性，不可以在编程中使用，是给浏览器自己使用的，该属性指向原型对象，和构造函数中的prototype指向一个同一个地址。 protoType proto指向同一个位置，但是存在位置不同，protoType存在在构造函数中，proto存在在实例化对象中。原型链简介实例对象和原型对象形成的链式结构,链式通过proto来链接。 起点是一个实例化对象，最终的重点是object的proto是null。数组的原型链: arr--&gt;Array.protoType--&gt;Object.protoType--&gt;null; 操作原型链123456789101112131415function Foo1(info) &#123; this.info = info;&#125;function Foo2(info) &#123; this.info = info;&#125;function Foo3(info) &#123; this.info = info;&#125;Foo2.prototype=new Foo1("Tom");//这里要注意顺序!!!!Foo3.prototype=new Foo2("jerry");var foo3=new Foo3("dog");console.dir(foo3); 原型链变成了 foo3–&gt;foo2—&gt;foo1—&gt;object。 通过重置原型对象的方式来修改原型链。这样修改原型链会丢失construtor属性，因为实例化对象中，并没有这个属性，这个属性只存在在构造函数的原型中。 继承原型继承就是上述的方法，让一个构造函数的原型指向一个实例。有以下几个缺点。 没有办法给直接继承过来的属性赋值。 继承过来的引用类型的数据，所有实例都是共享的。借用构造函数继承 改变this的方法，call,和apply方法，第一个参数是要改变的this，如果this是null则不会改变。 call函数可以有多个参数，第一个参数是this的指向，后面的参数传入原函数的参数 apply函数可以有两个参数，第一个也是this的指向，后面需要传入一个数组，数组里面是函数的参数。 了解以上知识后可以使用以下的代码来声明构造函数。123456789101112function Animall(name,voice)&#123; this.name=name; this.say=function()&#123; console.log(voice); &#125; var voice="dddd";&#125;function Cat(color,name,voice)&#123; //这里将Animal的构造函数指针改成了Cat类的this Animall.call(this,name,voice) this.color=color;&#125; 在子类，子构造函数Cat中借用了Animall的函数内容，相当于给给自己添加了属性。同理call可以换成apply类似。这里的Animall相当于一个普通的函数，没有new。 这个方法完美解决了以上两个问题。但是也产生了新的问题，没有继承父级构造函数原型上的成员。 组合继承12345678910111213function Animall(name,voice)&#123; this.name=name; this.say=function()&#123; console.log(voice); &#125; var voice="dddd";&#125;function Cat(color,name,voice)&#123; //这里将Animal的构造函数指针改成了Cat类的this Animall.call(this,name,voice) this.color=color;&#125;Cat.prototype=new Animall();//这里将原型链链接到Cat上 这种方法是以上两种方法的混合，解决了许多的缺点。 不一定正确的总结，构造函数中属性的开头一般是this.，私有属性，不能直接访问的属性的开头是var，共有的属性和方法放在原型中。 ES5 Object.create方法这个方法是一个ES5的新特性，在版本老旧的浏览器中可能不兼容，12345var obj=Object.create(null);var o1=&#123; name:lee;&#125;var o2=Object.create(o1); obj这种形式被创建的对象什么都不会有，proto也没有。o2被创建之后，会将proto指向o1。实际上函数内部相当于12345Object.protoType.create=function(obj)&#123; function Foo()&#123;&#125; foo.protoType=obj; return new Foo();&#125; 属性的复制一般把forin封装成函数，在使用这个方案时，如果原属性已经存在会被覆盖，不存在将会进行赋值。如果存在嵌套关系，可能会覆盖内层没有修改的数据。 $中的extend方法可以进行拷贝方式,第一个参数不如不写，是浅拷贝，只会修改最外面一层，如果true会进行深度拷贝，所有层都会被修改。第二个参数是可以修改的属性，所有的后续参数都会逐一合并到第二个参数。 (用递归编写)]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2Fday5%2F</url>
    <content type="text"><![CDATA[render函数我们有很多种方式来创建模板，可以直接在组件中声明，可以在script标签中声明，然后把选择器传到template属性。 也有一种新的方法，用render函数，一般通过createElement1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // tag name 标签名称 this.$slots.default // 子组件中的阵列 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) creatElemtn的参数1234567891011121314151617181920212223// @returns &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; // 一个 HTML 标签字符串，组件选项对象，或者一个返回值类型为String/Object的函数，必要参数 'div', // &#123;Object&#125; // 一个包含模板相关属性的数据对象 // 这样，您可以在 template 中使用这些属性.可选参数. &#123; // (详情见下一节) &#125;, // &#123;String | Array&#125; // 子节点(VNodes)，可以是一个字符串或者一个数组. 可选参数. [ createElement('h1', 'hello world'), createElement(MyComponent, &#123; props: &#123; someProp: 'foo' &#125; &#125;), 'bar' ]) 深入了解data object参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; // 和`v-bind:class`一样的 API 'class': &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API style: &#123; color: 'red', fontSize: '14px' &#125;, // 正常的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 props props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器基于 "on" // 所以不再支持如 v-on:keyup.enter 修饰器 // 需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅对于组件，用于监听原生事件，而不是组件内部使用 vm.$emit 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令. 注意事项：不能对绑定的旧值设值 // Vue 会为您持续追踪 directives: [ &#123; name: 'my-custom-directive', value: '2' expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // Scoped slots in the form of // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; h('span', props.text) &#125;, // 如果组件是其他组件的子组件，需为slot指定名称 slot: 'name-of-slot' // 其他特殊顶层属性 key: 'myKey', ref: 'myRef'&#125; 以上这些的属性会被区别对待，就像模板中的:class和:style一样 约束VNodes必须是唯一的。不可以在createElement中重复元素。比如1234567render: function (createElement) &#123; var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的VNodes myParagraphVNode, myParagraphVNode ])&#125; 如果要真的创建很多个相同的Vnodes可以使用不同的引用类型的地址。利用工厂函数来实现1234567render: function (createElement) &#123; return createElement('div', Array.apply(null, &#123; length: 20 &#125;).map(function () &#123; return createElement('p', 'hi') &#125;) )&#125; 这段创建了20个重复的vnodes 使用js来代替模板引擎模板引擎中的常用指令v-if和v-for，Vue在JS中并没有给他们实现对应的API，可以直接用js编写。1234&lt;ul v-if="items.length"&gt; &lt;li v-for="item in items"&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; 可以重写成123456789render: function (createElement) &#123; if (this.items.length) &#123; return createElement('ul', this.items.map(function (item) &#123; return createElement('li', item.name) &#125;)) &#125; else &#123; return createElement('p', 'No items found.') &#125;&#125; v-mode的实现也没有API12345678910111213render: function (createElement) &#123; var self = this return createElement('input', &#123; domProps: &#123; value: self.value &#125;, on: &#123; input: function (event) &#123; self.value = event.target.value &#125; &#125; &#125;) &#125; 事件按键修饰符对于 .capture 和 .once事件修饰符, Vue 提供了相应的前缀可以用于 on:Modifier(s) Prefix.capture !.once ~.capture.once or.once.capture ~! 12345on: &#123; '!click': this.doThisInCapturingMode, '~keyup': this.doThisOnce, `~!mouseover`: this.doThisOnceInCapturingMode&#125; 函数化组件函数化组件的一切都需要上下文来进行传递123456789101112Vue.component('my-component', &#123; functional: true, // 为了弥补缺少的实例 // 提供第二个参数作为上下文 render: function (createElement, context) &#123; // ... &#125;, // Props 可选 props: &#123; // ... &#125;&#125;) 要传递的属性有 props: 提供props 的对象 children: VNode 子节点的数组 slots: slots 对象 data: 传递给组件的 data 对象 parent: 对父组件的引用通常为了以下的目的我们可能会使用到函数化组件 程序化地在多个组件中选择一个 在将 children, props, data 传递给子组件之前操作它们。 放弃#自定义指令 简介全局定义12345678// 注册一个全局自定义指令 v-focusVue.directive('focus', &#123; // 当绑定元素插入到 DOM 中。 inserted是钩子函数 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 钩子函数 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。钩子函数的操作 el 要被操作的DOM元素 binding一个包含许多属性的对象 name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { - foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用 123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 当写成上述的形式的时候，相当于绑定了bind和update钩子。 对象字面量当指令需要多个参数的时候，可以传入一个字面量对象。1&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt; 然后通过binding.value来访问。 #混合 基础混合是需要单独定义的一个对象，当组件内部调用混合的时候，混合中的数据会被混入组件。12345678910111213141516// 定义一个混合对象var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125;&#125;// 定义一个使用混合对象的组件var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // -&gt; "hello from mixin!" 选项合并当混入的数据和组件本身的数据发生冲突时，将发生类似Vue.extend方法的数据合并。钩子冲突时，两个钩子都会被调用，先调用混合对象的钩子，值为对象的选项，将会被混合成一个对象，当键名冲突的时候，将会取用组件的键值。 全局混合12345678910111213// 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello!'&#125;)// -&gt; "hello!" 全局混合会影响所有实例 插件开发插件插件通常会增加一些全局的功能 添加全局方法或者属性，如: vue-element 添加全局资源：指令/过滤器/过渡等，如 vue-touch 通过全局 mixin方法添加一些组件选项，如: vuex 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router插件的使用规范，都应该给全局对象添加一个公开方法install，这个方法第一个参数是Vue构造器，第二个参数是可选对象。## 使用插件通过全局方法使用插件Vue.use(),也可以传入一个选项对象。1Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use会阻止注册相同插件多次]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2Fday6%2F</url>
    <content type="text"><![CDATA[起步实例化一个最简单的app 1234567var app=new Vue(&#123; el:"#app", data:&#123; message:"Helloe Vue!"+new Date(), lorem:'nihenpi' &#125; &#125;) el 代表选择器，把app制定到具体的dom元素，data代表数据，通常使用在模板引擎等位置。 V指令在一个标签内部定义一个自定义属性以v:开头，代表Vue指令。这个指令通常要对这个元素进行操作。 v-bind绑定操作，绑定元素的属性比如绑定这个元素的title属性，绑定到app内部的message数据。1234567891011121314151617181920## v-if表示可视性，根据绑定数据的布尔值来判断当前元素是否显示。```html &lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;seen&quot;&gt; &#123;&#123; lorem&#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue(&#123; el:&quot;#app&quot;, data:&#123; seen:true, lorem:&quot;我要隐藏了&quot; &#125; &#125;) &lt;/script&gt; 当你在控制台输入12345678910111213141516171819## v-for用于模板引擎，类似每次都会循环标签内的模板引擎进行输出```html &lt;div id=&quot;app&quot;&gt; &lt;span v-for=&quot;todo in TODOList&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue(&#123; el:&quot;#app&quot;, data:&#123; TODOList:[&quot;hahahah&quot;,&quot;hehehehehe&quot;,&quot;hohohohoho&quot;] &#125; &#125;) &lt;/script&gt; 网页上将会显示数组中的内容hahahah hehehehehe hohohohoho。 v-on事件监听可以给对应的元素设置事件，配合数据的绑定使用非常厉害。 1234567891011121314151617181920&lt;div id="app"&gt; &lt;span&gt; &#123;&#123;message&#125;&#125; &lt;/span&gt; &lt;input type="button" name="" value="一发逆转！" v-on:click="resever"&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: "#app", data: &#123; message: "我真是日了狗了" &#125;, methods: &#123; resever: function () &#123; this.message=this.message.split('').reverse().join(""); &#125; &#125; &#125;) &lt;/script&gt; 这样当点击按钮的时候，span标签内的文字也会跟着改变。 v-model可以给表单设置，把表单的value和数据进行绑定 123456789101112131415&lt;div id="app"&gt; &lt;span&gt; &#123;&#123;message&#125;&#125; &lt;/span&gt; &lt;/br&gt; &lt;input type="text" name="" v-model="message"&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: "#app", data: &#123; message: "我真是日了狗了" &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(3)%2F</url>
    <content type="text"><![CDATA[反馈预解析JS在执行的过程中分为两个阶段，预解析阶段，执行阶段在全局预解析的过程中，如果变量名和函数名相同，那么以函数为准。 预解析又分为 全局预解析 所有的变量和函数都会提前，同名的变量和函数，函数会覆盖同名变量。函数提升可以将函数体也提升。 函数内部的预解析 同于全局情况，但是会预解析形参。 先解析变量，在解析形参，再解析函数。也是会产生覆盖。 整体的过程是，先解析全局，执行全局，当调用函数时，解析函数内部，再执行函数。 作用域作用域分为全局作用域，函数作用域，不存在块级作用域的。1234&#123; var a=10;&#125;console.log(a);//10 以上在大括号外也可以访问到a，所以不存在块。 闭包封闭的包裹，在JS中只函数的作用域。 通过函数的嵌套来形成闭包，(内层函数和内层函数形成的作用域）。 闭包可以延长作用域的生命周期，正常函数执行之后，函数内部的变量就会被释放，而闭包的情况下，函数内部的变量还会被其他函数调用，不会被释放。用这个特性可以缓存一些中间的状态值。]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(4)%2F</url>
    <content type="text"><![CDATA[函数的属性 arguments 所有的实参 length 形参的个数 caller函数的调用者 name 函数的名称 arguments是一个类数组，有一个属性是callee，就是这个函数本身可用于递归。arguments比较消耗性能，不建议使用。ES6的箭头函数中也没有了这个属性。 事件队列JS的执行时单线程的当遇到比较复杂的运算的时候，后续的任务只能排队， 为了解决这个问题，提出了事件队列 事件队列中存放各种任务，也就是函数. 定时函数 事件函数 AJAX的回调函数(本身不是事件函数吗？) 在处理JS的过程中，当碰到以上几种情况的时候，不会直接执行这些函数，把他们缓存到实践队列中。 事件队列中任务执行的条件 主线程空闲 满足任务的触发条件 延时或者对应的事件触发，接收到服务器完成的数据，等等等。 Promise的then会放到事件队列的最前?会在事件轮循结束时调用，而其他的事件一般在第二次轮循的时候调用。 事件原生JS中return false只能阻止默认行为，不能阻止冒泡。只能阻止btn.onclick这种方式的默认行为。不能阻止addEventListener绑定的事件。JQuery中，return false既可以阻止冒泡，也可以阻止默认行为。 自定义事件12345678910111213function addEvent(obj,type,fn)&#123; obj.listener=obj.listener||&#123;&#125;; obj.listener[type]=obj.listener[type]||[]; obj.listener[type].push(fn); &#125; var obj=&#123;&#125;; addEvent(obj,'abc',function ()&#123; console.log("abc1"); &#125;); addEvent(obj,'abc',function ()&#123; console.log("abc2"); &#125;); console.dir(obj); #JQ插件]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(5)%2F</url>
    <content type="text"><![CDATA[正则API正则本身的API test exec 字符串的API,可以把参数传入正则表达式 在正则表达式后面加上g代表全局匹配。 search match split replace test 方法参数是一个字符串，检测是否满足正则。12var reg=/\d/;console.log(reg.test("asdfasf1"));//true execexec的参数是一个字符串，返回值是一个数组。和字符串match非全局匹配时方法类似。exec每次执行返回的数组信息很详细，只能通过遍历的方式来全局匹配。 search查找字符串的索引位置,如果没有返回-1.12var str="oijlklkjlj88";console.log(str.search(i));//1 ### split把字符串分割成数组123var str="oijlklkjlj88"; var arr=str.split("l"); console.log(arr);//demo.html:14 ["oij", "k", "kj", "j88"] match匹配，把符合参数的规则抽取转换成数组。 replace把所有符合规则的进行替换，第一个是规则，第二个替换成什么]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(6)%2F</url>
    <content type="text"><![CDATA[canvas H5的新特性，和传统的flash类似，称为画布，可以用来制作动画。 画横线画布的宽高必须用标签的属性来设置，不能用css，如果不设置宽高默认是300*150px。1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="cas" height="400px" width="600px"&gt;&lt;/canvas&gt; &lt;script&gt; onload=function()&#123; var cas=document.getElementById("cas"); //获取画图工具 var ctx=cas.getContext('2d'); //指定画图的起点 ctx.moveTo(100,100); // 划路径 ctx.lineTo(300,100); //描边 ctx.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 画矩形和直线类似，只不过连线路径的时候要连城一个正方形。12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="cas" height="400px" width="600px"&gt;&lt;/canvas&gt; &lt;script&gt; onload=function()&#123; var cas=document.getElementById("cas"); //获取画图工具 var ctx=cas.getContext('2d'); //指定画图的起点 ctx.moveTo(100,100); // 划路径 ctx.lineTo(300,100); ctx.lineTo(300,300); ctx.lineTo(100,300); ctx.lineTo(100,100); //描边 ctx.strokeStyle="#ccc"; //设置描边宽度 ctx.lineWidth=50; ctx.stroke(); //填充 ctx.fill(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 内外嵌套的矩形123456789101112131415161718192021222324252627282930313233343536373839 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="cas" height="400px" width="600px"&gt;&lt;/canvas&gt; &lt;script&gt; onload=function()&#123; var cas=document.getElementById("cas"); //获取画图工具 var ctx=cas.getContext('2d'); //指定画图的起点 ctx.moveTo(100,100); // 划路径 ctx.lineTo(300,100); ctx.lineTo(300,300); ctx.lineTo(100,300); ctx.lineTo(100,100); // 缝合接口 ctx.closePath(); ctx.moveTo(150,150); ctx.lineTo(150,250); ctx.lineTo(250,250); ctx.lineTo(250,150); ctx.lineTo(150,150); ctx.closePath(); //描边 ctx.strokeStyle="#ccc"; //设置描边宽度 ctx.lineWidth=10; ctx.stroke(); //填充 ctx.fill(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 关于闭合，手动闭合如果线宽比较大的话，会明显缺个角，补上这个角，可以多加0.1个像素。 beginPath()开启一个新的路线，可以区分和之前的路径颜色，宽度等等 正弦曲线1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="cas" height="400px" width="600px"&gt;&lt;/canvas&gt; &lt;script&gt; onload=function()&#123; var cas=document.getElementById("cas"); //获取画图工具 var ctx=cas.getContext('2d'); //指定画图的起点 ctx.moveTo(0,0); for(var i=0;i&lt;1000;i++)&#123; ctx.lineTo(i,100*Math.sin(i/30)+100); &#125; ctx.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(7)%2F</url>
    <content type="text"><![CDATA[web第三天响应式开发原因一般情况下网站会有移动端和PC端都会进行访问，但是屏幕的分辨率不一样。 1200px ​ 解决的办法有两种： 开发两套页面：PC和M端，这样做后台需要处理两个页面。 开发一个响应式界面:这样做后台需要处理一个网页，但是前端的工作量没什么变化。老站点一般用前者，新开发网站可能会使用第二套方法。媒体查询响应式页面通过区分屏幕的宽度来区分，需要用到属性查询功能。选择1200分辨率以上时，container设置1000px宽度，居中。1234567&lt;!--//screen可以省略--&gt;@media screen (min-width:1200px)&#123; .container&#123; width:1000px; margin:0 auto; &#125;&#125; bootstrap最终目的是提高开发的效率， container 固定宽度 container-fluid 宽度百分百珊栏布局可以嵌套.col-sm-n-offset-n n表示占位数 row 横排 col 竖排 xs 超小屏 sm 小屏幕 md 中屏 lg 大屏 offset-n 表示偏移 `col-xs-push-1 往右推 pull是拉 visible-lg 大屏显示 hidden-lg 大屏隐藏@font-face自定义字体/字体图标]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(8)%2F</url>
    <content type="text"><![CDATA[Web 第二天移动端事件touch移动端的事件，只有移动端才有,touch是一个事件组包含四个事件。 touchstart 手指触摸 不管几个手指 touchmove 手指在滑动的时候 touchend 手指离开屏幕 touchcancel 系统停止跟踪触摸时 不常用 被迫终止滑动时会触发移动端的事件要用addEventListener来绑定1234.addEventListener(&quot;touchstart&quot;, function ()&#123; console.log(&quot;start&quot;); &#125; 事件参数有以下几个常用属性 changedTouches 所有改变的触摸点集合 targetTouches 目标元素上所有触摸点集合 touches 所有触摸点 集合内的对象内的三组坐标 client 视口的坐标 page 页面的坐标 screen 屏幕上面的坐标 包括浏览器工具栏等等结束事件过渡结束事件transiitionEnd ，动画结束事件animationEnd这两个属性有兼容性问题，需要加私有前缀；tab事件tap轻触事件,封装在fastclick中，zepto中也有,移动端click会有延迟300ms,tap不会有。特点是: 没有滑动过 150ms内响应]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F2016%2F03%2F21%2F%E7%AC%94%E8%AE%B0%20(9)%2F</url>
    <content type="text"><![CDATA[移动web开发第一天移动端开发已经是必备技能移动端推进了H5的推广，手机浏览器，目前移动端浏览网页已经超过了PC端的访问，所以很重要。 移动端兼容性比较好移动端的浏览器，一般都版本较新。尤其是国内基本都是基于webkit内核，C3的属性一般需要些私有前缀-webkit-。 移动适配问题移动端需要考虑适配的问题，移动端的屏幕大小不一，不能像PC端一样设置版心。京东移动端项目采用百分比自适应布局，流式布局另外需要配置viewport。 流式布局就是不使用固定像素布局 viewport 视觉窗口用来承载网页，只在移动端才会有。 浏览器&gt;viewport&gt;网页 标准的移动端开发要求(viewport) 不能出现横向滚动条 （也可以认为是网页的宽度和浏览器的宽度一致） 缩放的比例和PC端保持一致 不允许页面自行缩放 怎么设置viewport在header里面meta标签 name=viewport 1&lt;meta name=&quot;viewport&quot;&gt; viewport 用那些属性 width 设置视口的宽度单位默认px 设置当前视口宽度为当前设备宽度content=&quot;device-width height 设置视口的高度单位默认px initial-scale 默认初始缩放比例content=&quot;inital-scale=1&quot; user-scalable 是否允许用户自己缩放 可以设置成yes no 1 0默认是可以缩放(yes 1) 如果设置多个属性参数 那么用逗号隔开就可以 也可以用快捷语法meta:vp来实现标准化设置 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width inital-scale=1 user-scalable=no&quot; &gt; 淘宝的viewport中设置了缩放，来解决高清屏幕的设备中图标失真的方法。 在京东项目中，会将背景图片单独进行压缩 来实现目的 移动端的容器宽度目前一般常用的主流的设计稿容器宽度一种是640 iphone4,另外一种是iphone6的750 tips图片的下间隙间隙的大小和字体的大小有关系x的下面两个脚就是基线(baseline)，图片会和他对齐，系统会预留y比x长的一块(yx) 也就会产生间隙。 font-size:0 ,vertical align, display:block,]]></content>
      <categories>
        <category>rubbish</category>
      </categories>
      <tags>
        <tag>废稿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的语义标签]]></title>
    <url>%2F2016%2F03%2F21%2Ftransition%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[transition进阶介绍 过渡就是当当前元素的属性发生变化时，不是立即切换，而是逐渐的发生变化，会产生动画效果。 transition-property 过渡属性过渡属性是选择切换时候发生过渡的属性。transition-property:width;宽度属性发生过渡 transition-duration 过渡时间发生变化时整个过渡的时长。transition-property:2s过渡时长为2秒钟 transition-delay 过渡延时设定一段时间之后发生过渡transition-delay：3s触发之后3秒钟之后发生过渡。 transition-timing-function动画过渡的方式有以下几个属性 linear 线性 匀速 ease 平滑过渡 慢快 慢快 默认 ease-in 慢变快 ease-out 块变慢 ease-in-out 慢快慢 cubic-bezier(, , , )： 特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内。一般使用工具生成就行了。 steps(n) 按步骤进行n是总共的步数，每进行一步就会停止一段时间 还有很多没啥用的不说了，上面感觉也有许多没啥用的一般只用过渡使用简单的小动画，所以以上几种过渡方式在用户看来并没有明显的区别缩写将以上几种属性写在一起，按照上面介绍的顺序transition: all 2s 1s linear 所有属性 过渡2s 延时1s 线性过渡一摸就会动的小鱼123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .fish&#123; background: url('http://ok0w43sns.bkt.clouddn.com/fish.png'); width: 174px; height: 126px; /*border: 1px solid gray;*/ &#125; .fish:hover&#123; transition: all 1s steps(11); background-position: 0 -1386px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="fish"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码执行结果如图:]]></content>
  </entry>
  <entry>
    <title><![CDATA[C3背景颜色的渐变]]></title>
    <url>%2F2016%2F03%2F19%2FC3%E9%A2%9C%E8%89%B2%E7%9A%84%E6%B8%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[C3背景颜色的渐变颜色的渐变是指从一个颜色逐渐变成另外一个颜色，具体体验在RGB值的改变，C3中不需要借助图片处理，可以直接生成许多颜色的渐变效果。节省了资源的占用，可以加快网页的加载速度。 线性渐变 线性渐变是沿着一个方向颜色产逐渐的变化 线性渐变的语法background:linear-gradient(to 目标方向 ,颜色,渐变到的颜色)线性渐变产生的颜色差在CSS中可以理解为背景图片，而不是背景颜色，所以必须用background-image或者background来进行设置。 目标方向可以是以下几种 top 从下到上 bottom 从上到下 left 从右到左 right 从左到右 ndeg n可以替换成度数 完全可以360度自定义方向 颜色的渐变可以设置多种颜色会一个向下一个颜色渐变最简单的渐变代码实现1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; div&#123; width: 800px; height: 300px; background: linear-gradient(to right,yellow,orange,red); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下: 渐变过程中颜色的范围background:linear-gradient(to(目标方向),颜色 百分比,渐变到的颜色 百分比，渐变到的颜色 百分比) 百分比的详解 百分比是指颜色渐变方向起始的百分比，颜色渐变方向末尾的百分比，带有百分比会阻止颜色的渐变，改变成到百分比立即切换，如果某个颜色没有写开始或者末尾百分比，颜色会正常渐变 由于第一个颜色起始肯定是0 所以只需要写末尾的百分比 由于最后一个颜色末尾肯定是100% 只需要写起始的百分比代码示例1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; div&#123; width: 800px; height: 300px; background: linear-gradient(to right,yellow 30%,orange 30%,orange 70%,red 70%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行后结果如下： 径向渐变 色彩渐变按照圆的半径扩散 径向渐变的语法background: radial-gradient( mpx npx at 位置，颜色 百分比，颜色 百分比)和线性渐变类似，区别在于m,n分别代表半径，当m=n或者只写m时，渐变是呈现圆形，否则呈现椭圆。 位置处可以填写以下几种位置 top 可以和除了bottom的搭配 bottom 可以和除了top的搭配 left 可以和除了right的搭配 right 可以和除了Left 的搭配 center 中心，可以和以上四种搭配 x y x y分别代表横纵坐标 小太阳示例1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; html&#123; height:100%; &#125; body&#123; margin: 0; background: radial-gradient(300px at top right ,orangered ,yellow,skyblue ) ; height:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下: 关于小案例中body的注意body本身的高度默认是0，他的高度一般由内容撑开，所以不能直接设置背景，当填写高度100%时候继承父元素html的高度，父元素填写100%的时候，会继承根元素的高度这时Body的高度就是浏览器一屏幕的高度。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C3背景新玩法]]></title>
    <url>%2F2016%2F03%2F14%2FC3%E4%B8%ADbackground%E7%9A%84%E6%96%B0%E7%8E%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[C3背景新玩法 CCS3背景相添加了许多新的特性，可以配合过渡属性不依靠JS也可以完成许多动画效果，十分的便捷。本文章介绍的是，一些C3中新添加的常用的基础的背景属性。 background-size属性background-size语法在之前设定盒子的背景图时，背景图不能进行缩放，只能对图片进行剪裁，而background-size属性解决了这个问题，可以让背景图像Img标签一样进行处理。 background-size有以下几个值 cover 覆盖 背景图保持长宽比放大，放大到充满整个盒子 contain 包含 背景图保持长宽比放大，放大到充满长或者宽 mpx npx 设置背景图的 宽高，可能会改变背景图的比例 显示不正常小示例12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$想不想知道后面写的是什么$&lt;/title&gt; &lt;style&gt; div&#123; width: 300px; height: 400px; float: left; margin-left: 50px; border: 1px solid black; background: url("img/lyf.jpg") no-repeat center; &#125; div:nth-child(1)&#123; background-size: contain; &#125; div:nth-child(2)&#123; background-size: cover; &#125; div:nth-child(3)&#123; background-size: 100px 100px ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div &gt;&lt;/div&gt;&lt;div &gt;&lt;/div&gt;&lt;div &gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如图: 多重背景 C3可以给一个盒子加载多个背景图，并可以一起显示 background语法background: 图片1的各种设置， 图片2的各种设置， 图片3的各种设置； 相框案例123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .picbox &#123; width: 623px; height: 417px; margin: 100px auto; background: url('img/bg1.png') no-repeat top left, url('img/bg2.png') no-repeat top right, url('img/bg3.png') no-repeat bottom right, url('img/bg4.png') no-repeat bottom left, url('img/dog.gif') no-repeat center/400px 270px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="picbox"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下:图片中的相框实际上是由四个图片拼接而成。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的语义标签]]></title>
    <url>%2F2016%2F03%2F13%2FHTML5%E7%9A%84%E8%AF%AD%E4%B9%89%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[HTML5的语义标签 语义标签是指没有特定的浏览器默认行为的标签 ,可以便于页面的维护，增加页面的可阅读性。同时也方便爬虫访问网页，对SEO起到优化的作用。 语义化标签的缘由 为什么要书写语义标签 SEO 优化搜索引擎对网页的排名(优化排名现金主要靠广告费) 规范的命名 便于代码的管理H5新增的语义化标签 H5常用的与仪表花钱 header 头部 nav 导航 main 主要内容 footer 页脚12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$别看我$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;nav&gt; &lt;/nav&gt;&lt;/header&gt;&lt;main&gt; &lt;/main&gt;&lt;footer&gt; &lt;/footer&gt;&lt;script src=jquery-3.1.1.js&gt;&lt;/script&gt;&lt;script&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
</search>
